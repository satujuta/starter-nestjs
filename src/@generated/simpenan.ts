import { Field } from '@nestjs/graphql';
import { ArgsType } from '@nestjs/graphql';
import { Type } from 'class-transformer';
import { Prisma } from '@prisma/client';
import { Int } from '@nestjs/graphql';
import { InputType } from '@nestjs/graphql';
import { ObjectType } from '@nestjs/graphql';
import { Float } from '@nestjs/graphql';
import * as Validator from 'class-validator';
import { registerEnumType } from '@nestjs/graphql';
import { HideField } from '@nestjs/graphql';

export enum UserNotificationScalarFieldEnum {
    id = "id",
    title = "title",
    subtitle = "subtitle",
    content = "content",
    createdAt = "createdAt",
    category = "category",
    isRead = "isRead",
    isCleared = "isCleared",
    userId = "userId",
    deepLink = "deepLink",
    fcmToken = "fcmToken"
}

export enum UserScalarFieldEnum {
    id = "id",
    firstName = "firstName",
    lastName = "lastName",
    email = "email",
    addressId = "addressId",
    userRole = "userRole",
    userType = "userType",
    avatarUrl = "avatarUrl",
    whatsappNumber = "whatsappNumber",
    whatsappVerifiedAt = "whatsappVerifiedAt",
    password = "password",
    referredById = "referredById",
    status = "status",
    schoolId = "schoolId",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    deletedAt = "deletedAt",
    theme = "theme"
}

export enum TransactionScalarFieldEnum {
    id = "id",
    amount = "amount",
    status = "status",
    transactionType = "transactionType",
    transactionCategory = "transactionCategory",
    currentBalance = "currentBalance",
    userId = "userId",
    accountId = "accountId",
    createdAt = "createdAt"
}

export enum ShippingScalarFieldEnum {
    id = "id",
    logisticName = "logisticName",
    deliveryDate = "deliveryDate",
    shippingStatus = "shippingStatus",
    addressId = "addressId",
    courier = "courier",
    estimatedTime = "estimatedTime",
    trackingNo = "trackingNo",
    orderId = "orderId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum SessionScalarFieldEnum {
    id = "id",
    token = "token",
    expiresAt = "expiresAt",
    createdAt = "createdAt",
    userId = "userId",
    device = "device",
    ipAddress = "ipAddress"
}

export enum SchoolScalarFieldEnum {
    id = "id",
    name = "name",
    addressId = "addressId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum RewardScalarFieldEnum {
    id = "id",
    name = "name",
    pointCost = "pointCost",
    description = "description",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProjectScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    projectCategory = "projectCategory",
    startDate = "startDate",
    endDate = "endDate",
    returnRate = "returnRate",
    goalAmount = "goalAmount",
    currentAmount = "currentAmount",
    minimumInvestment = "minimumInvestment",
    maxInvestor = "maxInvestor",
    accountId = "accountId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProgramCategoryScalarFieldEnum {
    id = "id",
    name = "name",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProgramScalarFieldEnum {
    id = "id",
    name = "name",
    startDate = "startDate",
    dueDate = "dueDate",
    description = "description",
    createdById = "createdById",
    categoryId = "categoryId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum UserType {
    PARENT = "PARENT",
    SCHOOL_HEAD = "SCHOOL_HEAD",
    STUDENT = "STUDENT"
}

export enum UserStatus {
    ACTIVE = "ACTIVE",
    PENDING = "PENDING",
    INACTIVE = "INACTIVE"
}

export enum UserRole {
    MEMBER = "MEMBER",
    ADMIN = "ADMIN",
    SUPERUSER = "SUPERUSER",
    STUDENT = "STUDENT"
}

export enum UserNotificationCategory {
    BILLING_ALERT = "BILLING_ALERT",
    ANNOUNCEMENT = "ANNOUNCEMENT",
    CHAT_MESSAGE = "CHAT_MESSAGE"
}

export enum TransactionType {
    DEBIT = "DEBIT",
    CREDIT = "CREDIT"
}

export enum TransactionStatus {
    PROCESSING = "PROCESSING",
    PENDING = "PENDING",
    FAILED = "FAILED",
    CANCELLED = "CANCELLED",
    COMPLETED = "COMPLETED"
}

export enum TransactionIsolationLevel {
    ReadUncommitted = "ReadUncommitted",
    ReadCommitted = "ReadCommitted",
    RepeatableRead = "RepeatableRead",
    Serializable = "Serializable"
}

export enum TransactionCategory {
    INVESTMENT = "INVESTMENT",
    INVESTMENT_RETURN = "INVESTMENT_RETURN",
    COMISSION_BONUS = "COMISSION_BONUS",
    WITHDRAWAL = "WITHDRAWAL",
    MEMBER_REGISTRATION = "MEMBER_REGISTRATION",
    STUDENT_REGISTRATION = "STUDENT_REGISTRATION"
}

export enum Theme {
    LIGHT = "LIGHT",
    DARK = "DARK"
}

export enum SortOrder {
    asc = "asc",
    desc = "desc"
}

export enum ShippingStatus {
    PROCESSING = "PROCESSING",
    DELIVERING = "DELIVERING",
    DELIVERED = "DELIVERED"
}

export enum ProjectCategory {
    PROPERTY = "PROPERTY",
    BUSSINESS = "BUSSINESS"
}

export enum PointType {
    REFERRING = "REFERRING",
    REDEEMING = "REDEEMING"
}

export enum NullsOrder {
    first = "first",
    last = "last"
}

export enum FileType {
    MP4 = "MP4",
    JPG = "JPG",
    PNG = "PNG",
    PDF = "PDF"
}

export enum AccountCategory {
    EQUITY = "EQUITY",
    PROJECT = "PROJECT",
    COMISSION = "COMISSION",
    CASH = "CASH",
    PLATFORM = "PLATFORM",
    BANK = "BANK"
}

export enum PostalCodeScalarFieldEnum {
    id = "id",
    code = "code"
}

export enum PointTransactionScalarFieldEnum {
    id = "id",
    amount = "amount",
    pointType = "pointType",
    transactionType = "transactionType",
    currentBalance = "currentBalance",
    userId = "userId",
    createdAt = "createdAt"
}

export enum PaymentConfirmationScalarFieldEnum {
    id = "id",
    ProofUrl = "ProofUrl",
    paymentId = "paymentId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum PaymentScalarFieldEnum {
    id = "id",
    adminFee = "adminFee",
    totalPayment = "totalPayment",
    orderId = "orderId",
    transactionId = "transactionId",
    createdAt = "createdAt"
}

export enum OrderScalarFieldEnum {
    id = "id",
    status = "status",
    orderById = "orderById",
    shippingId = "shippingId",
    isFullPaid = "isFullPaid",
    cost = "cost",
    platformFee = "platformFee",
    total = "total",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ItemScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    price = "price",
    qty = "qty",
    userRole = "userRole",
    orderId = "orderId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ImagesScalarFieldEnum {
    id = "id",
    fileType = "fileType",
    filesize = "filesize",
    url = "url",
    hotelImageId = "hotelImageId",
    programImageId = "programImageId",
    rewardImageId = "rewardImageId",
    projectImageId = "projectImageId",
    createdAt = "createdAt"
}

export enum HotelScalarFieldEnum {
    id = "id",
    name = "name",
    addressId = "addressId",
    description = "description",
    rating = "rating",
    startDate = "startDate",
    quota = "quota",
    createdById = "createdById",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum FileScalarFieldEnum {
    id = "id",
    fileType = "fileType",
    filesize = "filesize",
    name = "name",
    description = "description",
    url = "url",
    createdById = "createdById",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum FaqScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum DistrictScalarFieldEnum {
    id = "id",
    name = "name"
}

export enum CityScalarFieldEnum {
    id = "id",
    name = "name"
}

export enum CheckInScalarFieldEnum {
    id = "id",
    userId = "userId",
    hotelId = "hotelId",
    checkInAt = "checkInAt",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum BankScalarFieldEnum {
    id = "id",
    name = "name",
    logoUrl = "logoUrl",
    accountNumber = "accountNumber",
    accountId = "accountId"
}

export enum AddressScalarFieldEnum {
    id = "id",
    name = "name",
    cityId = "cityId",
    districtId = "districtId",
    postalCodeId = "postalCodeId"
}

export enum AccountScalarFieldEnum {
    id = "id",
    accountNumber = "accountNumber",
    name = "name",
    balance = "balance",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    userId = "userId",
    accountCategory = "accountCategory"
}

registerEnumType(AccountScalarFieldEnum, { name: 'AccountScalarFieldEnum', description: undefined })
registerEnumType(AddressScalarFieldEnum, { name: 'AddressScalarFieldEnum', description: undefined })
registerEnumType(BankScalarFieldEnum, { name: 'BankScalarFieldEnum', description: undefined })
registerEnumType(CheckInScalarFieldEnum, { name: 'CheckInScalarFieldEnum', description: undefined })
registerEnumType(CityScalarFieldEnum, { name: 'CityScalarFieldEnum', description: undefined })
registerEnumType(DistrictScalarFieldEnum, { name: 'DistrictScalarFieldEnum', description: undefined })
registerEnumType(FaqScalarFieldEnum, { name: 'FaqScalarFieldEnum', description: undefined })
registerEnumType(FileScalarFieldEnum, { name: 'FileScalarFieldEnum', description: undefined })
registerEnumType(HotelScalarFieldEnum, { name: 'HotelScalarFieldEnum', description: undefined })
registerEnumType(ImagesScalarFieldEnum, { name: 'ImagesScalarFieldEnum', description: undefined })
registerEnumType(ItemScalarFieldEnum, { name: 'ItemScalarFieldEnum', description: undefined })
registerEnumType(OrderScalarFieldEnum, { name: 'OrderScalarFieldEnum', description: undefined })
registerEnumType(PaymentScalarFieldEnum, { name: 'PaymentScalarFieldEnum', description: undefined })
registerEnumType(PaymentConfirmationScalarFieldEnum, { name: 'PaymentConfirmationScalarFieldEnum', description: undefined })
registerEnumType(PointTransactionScalarFieldEnum, { name: 'PointTransactionScalarFieldEnum', description: undefined })
registerEnumType(PostalCodeScalarFieldEnum, { name: 'PostalCodeScalarFieldEnum', description: undefined })
registerEnumType(AccountCategory, { name: 'AccountCategory', description: undefined })
registerEnumType(FileType, { name: 'FileType', description: undefined })
registerEnumType(NullsOrder, { name: 'NullsOrder', description: undefined })
registerEnumType(PointType, { name: 'PointType', description: undefined })
registerEnumType(ProjectCategory, { name: 'ProjectCategory', description: undefined })
registerEnumType(ShippingStatus, { name: 'ShippingStatus', description: undefined })
registerEnumType(SortOrder, { name: 'SortOrder', description: undefined })
registerEnumType(Theme, { name: 'Theme', description: undefined })
registerEnumType(TransactionCategory, { name: 'TransactionCategory', description: undefined })
registerEnumType(TransactionIsolationLevel, { name: 'TransactionIsolationLevel', description: undefined })
registerEnumType(TransactionStatus, { name: 'TransactionStatus', description: undefined })
registerEnumType(TransactionType, { name: 'TransactionType', description: undefined })
registerEnumType(UserNotificationCategory, { name: 'UserNotificationCategory', description: undefined })
registerEnumType(UserRole, { name: 'UserRole', description: undefined })
registerEnumType(UserStatus, { name: 'UserStatus', description: undefined })
registerEnumType(UserType, { name: 'UserType', description: undefined })
registerEnumType(ProgramScalarFieldEnum, { name: 'ProgramScalarFieldEnum', description: undefined })
registerEnumType(ProgramCategoryScalarFieldEnum, { name: 'ProgramCategoryScalarFieldEnum', description: undefined })
registerEnumType(ProjectScalarFieldEnum, { name: 'ProjectScalarFieldEnum', description: undefined })
registerEnumType(RewardScalarFieldEnum, { name: 'RewardScalarFieldEnum', description: undefined })
registerEnumType(SchoolScalarFieldEnum, { name: 'SchoolScalarFieldEnum', description: undefined })
registerEnumType(SessionScalarFieldEnum, { name: 'SessionScalarFieldEnum', description: undefined })
registerEnumType(ShippingScalarFieldEnum, { name: 'ShippingScalarFieldEnum', description: undefined })
registerEnumType(TransactionScalarFieldEnum, { name: 'TransactionScalarFieldEnum', description: undefined })
registerEnumType(UserScalarFieldEnum, { name: 'UserScalarFieldEnum', description: undefined })
registerEnumType(UserNotificationScalarFieldEnum, { name: 'UserNotificationScalarFieldEnum', description: undefined })

@ArgsType()
export class AccountAggregateArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AccountCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregateInput>;
    @Field(() => AccountAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregateInput>;
    @Field(() => AccountSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregateInput>;
    @Field(() => AccountMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregateInput>;
    @Field(() => AccountMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregateInput>;
}

@InputType()
export class AccountAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    balance?: true;
}

@ObjectType()
export class AccountAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Float, {nullable:true})
    balance?: number;
}

@InputType()
export class AccountAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
}

@InputType()
export class AccountCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    balance?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class AccountCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    balance!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    accountCategory!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class AccountCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@ObjectType()
export class AccountCount {
    @Field(() => Int, {nullable:false})
    transactions?: number;
}

@InputType()
export class AccountCreateManyUserInputEnvelope {
    @Field(() => [AccountCreateManyUserInput], {nullable:false})
    @Type(() => AccountCreateManyUserInput)
    data!: Array<AccountCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AccountCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
}

@InputType()
export class AccountCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
}

@InputType()
export class AccountCreateNestedManyWithoutUserInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
}

@InputType()
export class AccountCreateNestedOneWithoutBankAccountInput {
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create?: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountCreateOrConnectWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutBankAccountInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutBankAccountInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateNestedOneWithoutProjectInput {
    @Field(() => AccountCreateWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateWithoutProjectInput)
    create?: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountCreateOrConnectWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutProjectInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutProjectInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateNestedOneWithoutTransactionsInput {
    @Field(() => AccountCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionsInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionsInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionsInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateOrConnectWithoutBankAccountInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create!: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutProjectInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutProjectInput, {nullable:false})
    @Type(() => AccountCreateWithoutProjectInput)
    create!: InstanceType<typeof AccountCreateWithoutProjectInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutTransactionsInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionsInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionsInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutUserInput, {nullable:false})
    @Type(() => AccountCreateWithoutUserInput)
    create!: InstanceType<typeof AccountCreateWithoutUserInput>;
}

@InputType()
export class AccountCreateWithoutBankAccountInput {
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @Field(() => TransactionCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutProjectInput {
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @Field(() => TransactionCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutAccountInput>;
    @Field(() => BankCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutTransactionsInput {
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @Field(() => ProjectCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @Field(() => BankCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @Field(() => BankCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateInput {
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @Field(() => TransactionCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @Field(() => BankCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@ArgsType()
export class AccountGroupByArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithAggregationInput>;
    @Field(() => [AccountScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof AccountScalarFieldEnum>;
    @Field(() => AccountScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof AccountScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AccountCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregateInput>;
    @Field(() => AccountAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregateInput>;
    @Field(() => AccountSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregateInput>;
    @Field(() => AccountMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregateInput>;
    @Field(() => AccountMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregateInput>;
}

@ObjectType()
export class AccountGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false})
    balance!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => AccountCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregate>;
    @Field(() => AccountAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregate>;
    @Field(() => AccountSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregate>;
    @Field(() => AccountMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregate>;
    @Field(() => AccountMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregate>;
}

@InputType()
export class AccountListRelationFilter {
    @Field(() => AccountWhereInput, {nullable:true})
    every?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    some?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    none?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    balance?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
}

@ObjectType()
export class AccountMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => AccountCategory, {nullable:true})
    accountCategory?: keyof typeof AccountCategory;
}

@InputType()
export class AccountMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@InputType()
export class AccountMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    balance?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
}

@ObjectType()
export class AccountMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => AccountCategory, {nullable:true})
    accountCategory?: keyof typeof AccountCategory;
}

@InputType()
export class AccountMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@InputType()
export class AccountOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class AccountOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    accountNumber?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
    @Field(() => AccountCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountOrderByAggregateInput>;
    @Field(() => AccountAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgOrderByAggregateInput>;
    @Field(() => AccountMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxOrderByAggregateInput>;
    @Field(() => AccountMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinOrderByAggregateInput>;
    @Field(() => AccountSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumOrderByAggregateInput>;
}

@InputType()
export class AccountOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    accountNumber?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => TransactionOrderByRelationAggregateInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionOrderByRelationAggregateInput>;
    @Field(() => ProjectOrderByWithRelationInput, {nullable:true})
    project?: InstanceType<typeof ProjectOrderByWithRelationInput>;
    @Field(() => BankOrderByWithRelationInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankOrderByWithRelationInput>;
}

@InputType()
export class AccountRelationFilter {
    @Field(() => AccountWhereInput, {nullable:true})
    is?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    isNot?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountScalarWhereWithAggregatesInput {
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    balance?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => EnumAccountCategoryWithAggregatesFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryWithAggregatesFilter>;
}

@InputType()
export class AccountScalarWhereInput {
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    AND?: Array<AccountScalarWhereInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    OR?: Array<AccountScalarWhereInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    NOT?: Array<AccountScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    balance?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
}

@InputType()
export class AccountSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    balance?: true;
}

@ObjectType()
export class AccountSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => Float, {nullable:true})
    balance?: number;
}

@InputType()
export class AccountSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    balance?: keyof typeof SortOrder;
}

@InputType()
export class AccountUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
}

@InputType()
export class AccountUncheckedCreateWithoutBankAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutProjectInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutAccountInput>;
    @Field(() => BankUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutTransactionsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => ProjectUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @Field(() => BankUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @Field(() => BankUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @Field(() => Float, {nullable:true})
    balance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutAccountInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutAccountInput>;
    @Field(() => ProjectUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @Field(() => BankUncheckedCreateNestedOneWithoutAccountInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => [AccountUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<AccountUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<AccountUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [AccountUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<AccountUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    @Type(() => AccountScalarWhereInput)
    deleteMany?: Array<AccountScalarWhereInput>;
}

@InputType()
export class AccountUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutBankAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutProjectInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutAccountNestedInput>;
    @Field(() => BankUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutTransactionsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => ProjectUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUncheckedUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateManyMutationInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUpdateManyWithWhereWithoutUserInput {
    @Field(() => AccountScalarWhereInput, {nullable:false})
    @Type(() => AccountScalarWhereInput)
    where!: InstanceType<typeof AccountScalarWhereInput>;
    @Field(() => AccountUpdateManyMutationInput, {nullable:false})
    @Type(() => AccountUpdateManyMutationInput)
    data!: InstanceType<typeof AccountUpdateManyMutationInput>;
}

@InputType()
export class AccountUpdateManyWithoutUserNestedInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => [AccountUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<AccountUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<AccountUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [AccountUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<AccountUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    @Type(() => AccountScalarWhereInput)
    deleteMany?: Array<AccountScalarWhereInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutBankAccountNestedInput {
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create?: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountCreateOrConnectWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutBankAccountInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutBankAccountInput>;
    @Field(() => AccountUpsertWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountUpsertWithoutBankAccountInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutBankAccountInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutBankAccountInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutBankAccountInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutProjectNestedInput {
    @Field(() => AccountCreateWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateWithoutProjectInput)
    create?: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountCreateOrConnectWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutProjectInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutProjectInput>;
    @Field(() => AccountUpsertWithoutProjectInput, {nullable:true})
    @Type(() => AccountUpsertWithoutProjectInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutProjectInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutProjectInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutProjectInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutProjectInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutTransactionsNestedInput {
    @Field(() => AccountCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionsInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionsInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionsInput>;
    @Field(() => AccountUpsertWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountUpsertWithoutTransactionsInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutTransactionsInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutTransactionsInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutTransactionsInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutTransactionsInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutBankAccountInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountUpdateWithoutBankAccountInput)
    data!: InstanceType<typeof AccountUpdateWithoutBankAccountInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutProjectInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutProjectInput, {nullable:false})
    @Type(() => AccountUpdateWithoutProjectInput)
    data!: InstanceType<typeof AccountUpdateWithoutProjectInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutTransactionsInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionsInput)
    data!: InstanceType<typeof AccountUpdateWithoutTransactionsInput>;
}

@InputType()
export class AccountUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateWithoutUserInput, {nullable:false})
    @Type(() => AccountUpdateWithoutUserInput)
    data!: InstanceType<typeof AccountUpdateWithoutUserInput>;
}

@InputType()
export class AccountUpdateWithoutBankAccountInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutProjectInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutAccountNestedInput>;
    @Field(() => BankUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutTransactionsInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => ProjectUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutUserInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateInput {
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    balance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutAccountNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutAccountNestedInput>;
    @Field(() => ProjectUpdateOneWithoutAccountNestedInput, {nullable:true})
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @Field(() => BankUpdateOneWithoutAccountNestedInput, {nullable:true})
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateWithoutUserInput, {nullable:false})
    @Type(() => AccountUpdateWithoutUserInput)
    update!: InstanceType<typeof AccountUpdateWithoutUserInput>;
    @Field(() => AccountCreateWithoutUserInput, {nullable:false})
    @Type(() => AccountCreateWithoutUserInput)
    create!: InstanceType<typeof AccountCreateWithoutUserInput>;
}

@InputType()
export class AccountUpsertWithoutBankAccountInput {
    @Field(() => AccountUpdateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountUpdateWithoutBankAccountInput)
    update!: InstanceType<typeof AccountUpdateWithoutBankAccountInput>;
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create!: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountUpsertWithoutProjectInput {
    @Field(() => AccountUpdateWithoutProjectInput, {nullable:false})
    @Type(() => AccountUpdateWithoutProjectInput)
    update!: InstanceType<typeof AccountUpdateWithoutProjectInput>;
    @Field(() => AccountCreateWithoutProjectInput, {nullable:false})
    @Type(() => AccountCreateWithoutProjectInput)
    create!: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountUpsertWithoutTransactionsInput {
    @Field(() => AccountUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionsInput)
    update!: InstanceType<typeof AccountUpdateWithoutTransactionsInput>;
    @Field(() => AccountCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionsInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionsInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [AccountWhereInput], {nullable:true})
    AND?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    OR?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    NOT?: Array<AccountWhereInput>;
    @Field(() => IntNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    balance?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    project?: InstanceType<typeof ProjectNullableRelationFilter>;
    @Field(() => BankNullableRelationFilter, {nullable:true})
    bankAccount?: InstanceType<typeof BankNullableRelationFilter>;
}

@InputType()
export class AccountWhereInput {
    @Field(() => [AccountWhereInput], {nullable:true})
    AND?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    OR?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    NOT?: Array<AccountWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    balance?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    project?: InstanceType<typeof ProjectNullableRelationFilter>;
    @Field(() => BankNullableRelationFilter, {nullable:true})
    bankAccount?: InstanceType<typeof BankNullableRelationFilter>;
}

@ObjectType()
export class Account {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:true})
    accountNumber!: number | null;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false,defaultValue:0})
    balance!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => [Transaction], {nullable:true})
    transactions?: Array<Transaction>;
    @Field(() => Project, {nullable:true})
    project?: InstanceType<typeof Project> | null;
    @Field(() => Bank, {nullable:true})
    bankAccount?: InstanceType<typeof Bank> | null;
    @Field(() => AccountCount, {nullable:false})
    _count?: InstanceType<typeof AccountCount>;
}

@ObjectType()
export class AggregateAccount {
    @Field(() => AccountCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregate>;
    @Field(() => AccountAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregate>;
    @Field(() => AccountSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregate>;
    @Field(() => AccountMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregate>;
    @Field(() => AccountMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregate>;
}

@ArgsType()
export class CreateManyAccountArgs {
    @Field(() => [AccountCreateManyInput], {nullable:false})
    @Type(() => AccountCreateManyInput)
    data!: Array<AccountCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneAccountArgs {
    @Field(() => AccountCreateInput, {nullable:false})
    @Type(() => AccountCreateInput)
    data!: InstanceType<typeof AccountCreateInput>;
}

@ArgsType()
export class DeleteManyAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@ArgsType()
export class DeleteOneAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstAccountOrThrowArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindFirstAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindManyAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueAccountOrThrowArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyAccountArgs {
    @Field(() => AccountUpdateManyMutationInput, {nullable:false})
    @Type(() => AccountUpdateManyMutationInput)
    data!: InstanceType<typeof AccountUpdateManyMutationInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@ArgsType()
export class UpdateOneAccountArgs {
    @Field(() => AccountUpdateInput, {nullable:false})
    @Type(() => AccountUpdateInput)
    data!: InstanceType<typeof AccountUpdateInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateInput, {nullable:false})
    @Type(() => AccountCreateInput)
    create!: InstanceType<typeof AccountCreateInput>;
    @Field(() => AccountUpdateInput, {nullable:false})
    @Type(() => AccountUpdateInput)
    update!: InstanceType<typeof AccountUpdateInput>;
}

@ArgsType()
export class AddressAggregateArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AddressCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregateInput>;
    @Field(() => AddressAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregateInput>;
    @Field(() => AddressSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregateInput>;
    @Field(() => AddressMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregateInput>;
    @Field(() => AddressMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregateInput>;
}

@InputType()
export class AddressAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCodeId?: true;
}

@ObjectType()
export class AddressAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    cityId?: number;
    @Field(() => Float, {nullable:true})
    districtId?: number;
    @Field(() => Float, {nullable:true})
    postalCodeId?: number;
}

@InputType()
export class AddressAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
}

@InputType()
export class AddressCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCodeId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class AddressCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class AddressCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
}

@InputType()
export class AddressCreateManyCityInputEnvelope {
    @Field(() => [AddressCreateManyCityInput], {nullable:false})
    @Type(() => AddressCreateManyCityInput)
    data!: Array<AddressCreateManyCityInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AddressCreateManyCityInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    districtId!: number;
    @HideField()
    postalCodeId!: number;
}

@InputType()
export class AddressCreateManyDistrictInputEnvelope {
    @Field(() => [AddressCreateManyDistrictInput], {nullable:false})
    @Type(() => AddressCreateManyDistrictInput)
    data!: Array<AddressCreateManyDistrictInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AddressCreateManyDistrictInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    cityId!: number;
    @HideField()
    postalCodeId!: number;
}

@InputType()
export class AddressCreateManyPostalCodeInputEnvelope {
    @Field(() => [AddressCreateManyPostalCodeInput], {nullable:false})
    @Type(() => AddressCreateManyPostalCodeInput)
    data!: Array<AddressCreateManyPostalCodeInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AddressCreateManyPostalCodeInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    cityId!: number;
    @HideField()
    districtId!: number;
}

@InputType()
export class AddressCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    cityId!: number;
    @HideField()
    districtId!: number;
    @HideField()
    postalCodeId!: number;
}

@InputType()
export class AddressCreateNestedManyWithoutCityInput {
    @Field(() => [AddressCreateWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateWithoutCityInput)
    create?: Array<AddressCreateWithoutCityInput>;
    @Field(() => [AddressCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutCityInput>;
    @Field(() => AddressCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyCityInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressCreateNestedManyWithoutDistrictInput {
    @Field(() => [AddressCreateWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutDistrictInput)
    create?: Array<AddressCreateWithoutDistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutDistrictInput>;
    @Field(() => AddressCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyDistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressCreateNestedManyWithoutPostalCodeInput {
    @Field(() => [AddressCreateWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create?: Array<AddressCreateWithoutPostalCodeInput>;
    @Field(() => [AddressCreateOrConnectWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutPostalCodeInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutPostalCodeInput>;
    @Field(() => AddressCreateManyPostalCodeInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyPostalCodeInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyPostalCodeInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressCreateNestedOneWithoutHotelInput {
    @Field(() => AddressCreateWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateWithoutHotelInput)
    create?: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressCreateOrConnectWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutHotelInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutHotelInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutSchoolInput {
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateWithoutSchoolInput)
    create?: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressCreateOrConnectWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutSchoolInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutShippingInput {
    @Field(() => AddressCreateWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateWithoutShippingInput)
    create?: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutShippingInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutUserInput {
    @Field(() => AddressCreateWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateWithoutUserInput)
    create?: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressCreateOrConnectWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutUserInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutUserInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateOrConnectWithoutCityInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutCityInput, {nullable:false})
    @Type(() => AddressCreateWithoutCityInput)
    create!: InstanceType<typeof AddressCreateWithoutCityInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutDistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutDistrictInput, {nullable:false})
    @Type(() => AddressCreateWithoutDistrictInput)
    create!: InstanceType<typeof AddressCreateWithoutDistrictInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutHotelInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutHotelInput, {nullable:false})
    @Type(() => AddressCreateWithoutHotelInput)
    create!: InstanceType<typeof AddressCreateWithoutHotelInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutPostalCodeInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutPostalCodeInput, {nullable:false})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create!: InstanceType<typeof AddressCreateWithoutPostalCodeInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutSchoolInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressCreateWithoutSchoolInput)
    create!: InstanceType<typeof AddressCreateWithoutSchoolInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutShippingInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutShippingInput, {nullable:false})
    @Type(() => AddressCreateWithoutShippingInput)
    create!: InstanceType<typeof AddressCreateWithoutShippingInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutUserInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutUserInput, {nullable:false})
    @Type(() => AddressCreateWithoutUserInput)
    create!: InstanceType<typeof AddressCreateWithoutUserInput>;
}

@InputType()
export class AddressCreateWithoutCityInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutDistrictInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutHotelInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutPostalCodeInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutSchoolInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutShippingInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutAddressInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutAddressInput>;
    @Field(() => DistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutAddressInput>;
    @Field(() => PostalCodeCreateNestedOneWithoutAddressInput, {nullable:false})
    postalCode!: InstanceType<typeof PostalCodeCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@ArgsType()
export class AddressGroupByArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithAggregationInput>;
    @Field(() => [AddressScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof AddressScalarFieldEnum>;
    @Field(() => AddressScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof AddressScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AddressCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregateInput>;
    @Field(() => AddressAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregateInput>;
    @Field(() => AddressSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregateInput>;
    @Field(() => AddressMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregateInput>;
    @Field(() => AddressMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregateInput>;
}

@ObjectType()
export class AddressGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => AddressCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregate>;
    @Field(() => AddressAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregate>;
    @Field(() => AddressSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregate>;
    @Field(() => AddressMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregate>;
    @Field(() => AddressMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregate>;
}

@InputType()
export class AddressListRelationFilter {
    @Field(() => AddressWhereInput, {nullable:true})
    every?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    some?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    none?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCodeId?: true;
}

@ObjectType()
export class AddressMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    cityId?: number;
    @Field(() => Int, {nullable:true})
    districtId?: number;
    @Field(() => Int, {nullable:true})
    postalCodeId?: number;
}

@InputType()
export class AddressMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
}

@InputType()
export class AddressMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCodeId?: true;
}

@ObjectType()
export class AddressMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    cityId?: number;
    @Field(() => Int, {nullable:true})
    districtId?: number;
    @Field(() => Int, {nullable:true})
    postalCodeId?: number;
}

@InputType()
export class AddressMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
}

@InputType()
export class AddressOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class AddressOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
    @Field(() => AddressCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountOrderByAggregateInput>;
    @Field(() => AddressAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgOrderByAggregateInput>;
    @Field(() => AddressMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxOrderByAggregateInput>;
    @Field(() => AddressMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinOrderByAggregateInput>;
    @Field(() => AddressSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumOrderByAggregateInput>;
}

@InputType()
export class AddressOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
    @Field(() => CityOrderByWithRelationInput, {nullable:true})
    city?: InstanceType<typeof CityOrderByWithRelationInput>;
    @Field(() => DistrictOrderByWithRelationInput, {nullable:true})
    district?: InstanceType<typeof DistrictOrderByWithRelationInput>;
    @Field(() => PostalCodeOrderByWithRelationInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeOrderByWithRelationInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotel?: InstanceType<typeof HotelOrderByWithRelationInput>;
    @Field(() => SchoolOrderByWithRelationInput, {nullable:true})
    school?: InstanceType<typeof SchoolOrderByWithRelationInput>;
    @Field(() => ShippingOrderByWithRelationInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingOrderByWithRelationInput>;
}

@InputType()
export class AddressRelationFilter {
    @Field(() => AddressWhereInput, {nullable:true})
    is?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    isNot?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressScalarWhereWithAggregatesInput {
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    cityId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    districtId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    postalCodeId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class AddressScalarWhereInput {
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    AND?: Array<AddressScalarWhereInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    OR?: Array<AddressScalarWhereInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    NOT?: Array<AddressScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFilter>;
}

@InputType()
export class AddressSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCodeId?: true;
}

@ObjectType()
export class AddressSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    cityId?: number;
    @Field(() => Int, {nullable:true})
    districtId?: number;
    @Field(() => Int, {nullable:true})
    postalCodeId?: number;
}

@InputType()
export class AddressSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCodeId?: keyof typeof SortOrder;
}

@InputType()
export class AddressUncheckedCreateNestedManyWithoutCityInput {
    @Field(() => [AddressCreateWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateWithoutCityInput)
    create?: Array<AddressCreateWithoutCityInput>;
    @Field(() => [AddressCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutCityInput>;
    @Field(() => AddressCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyCityInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressUncheckedCreateNestedManyWithoutDistrictInput {
    @Field(() => [AddressCreateWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutDistrictInput)
    create?: Array<AddressCreateWithoutDistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutDistrictInput>;
    @Field(() => AddressCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyDistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressUncheckedCreateNestedManyWithoutPostalCodeInput {
    @Field(() => [AddressCreateWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create?: Array<AddressCreateWithoutPostalCodeInput>;
    @Field(() => [AddressCreateOrConnectWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutPostalCodeInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutPostalCodeInput>;
    @Field(() => AddressCreateManyPostalCodeInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyPostalCodeInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyPostalCodeInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressUncheckedCreateWithoutCityInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutDistrictInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutPostalCodeInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutSchoolInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutShippingInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutCityNestedInput {
    @Field(() => [AddressCreateWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateWithoutCityInput)
    create?: Array<AddressCreateWithoutCityInput>;
    @Field(() => [AddressCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutCityInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutCityInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutCityInput>;
    @Field(() => AddressCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyCityInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutCityInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutCityInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutCityInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutCityInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutCityInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutCityInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutDistrictNestedInput {
    @Field(() => [AddressCreateWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutDistrictInput)
    create?: Array<AddressCreateWithoutDistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutDistrictInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutDistrictInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutDistrictInput>;
    @Field(() => AddressCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyDistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutDistrictInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutDistrictInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutDistrictInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutDistrictInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutDistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutPostalCodeNestedInput {
    @Field(() => [AddressCreateWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create?: Array<AddressCreateWithoutPostalCodeInput>;
    @Field(() => [AddressCreateOrConnectWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutPostalCodeInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutPostalCodeInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutPostalCodeInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutPostalCodeInput>;
    @Field(() => AddressCreateManyPostalCodeInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyPostalCodeInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyPostalCodeInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutPostalCodeInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutPostalCodeInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutPostalCodeInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutPostalCodeInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutPostalCodeInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutCityInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutDistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutPostalCodeInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutSchoolInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutShippingInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUpdateManyWithWhereWithoutCityInput {
    @Field(() => AddressScalarWhereInput, {nullable:false})
    @Type(() => AddressScalarWhereInput)
    where!: InstanceType<typeof AddressScalarWhereInput>;
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
}

@InputType()
export class AddressUpdateManyWithWhereWithoutDistrictInput {
    @Field(() => AddressScalarWhereInput, {nullable:false})
    @Type(() => AddressScalarWhereInput)
    where!: InstanceType<typeof AddressScalarWhereInput>;
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
}

@InputType()
export class AddressUpdateManyWithWhereWithoutPostalCodeInput {
    @Field(() => AddressScalarWhereInput, {nullable:false})
    @Type(() => AddressScalarWhereInput)
    where!: InstanceType<typeof AddressScalarWhereInput>;
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
}

@InputType()
export class AddressUpdateManyWithoutCityNestedInput {
    @Field(() => [AddressCreateWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateWithoutCityInput)
    create?: Array<AddressCreateWithoutCityInput>;
    @Field(() => [AddressCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutCityInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutCityInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutCityInput>;
    @Field(() => AddressCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyCityInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutCityInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutCityInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutCityInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutCityInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutCityInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUpdateManyWithoutDistrictNestedInput {
    @Field(() => [AddressCreateWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutDistrictInput)
    create?: Array<AddressCreateWithoutDistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutDistrictInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutDistrictInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutDistrictInput>;
    @Field(() => AddressCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyDistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutDistrictInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutDistrictInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutDistrictInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutDistrictInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutDistrictInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUpdateManyWithoutPostalCodeNestedInput {
    @Field(() => [AddressCreateWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create?: Array<AddressCreateWithoutPostalCodeInput>;
    @Field(() => [AddressCreateOrConnectWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutPostalCodeInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutPostalCodeInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutPostalCodeInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutPostalCodeInput>;
    @Field(() => AddressCreateManyPostalCodeInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManyPostalCodeInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManyPostalCodeInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutPostalCodeInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutPostalCodeInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutPostalCodeInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutPostalCodeInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutPostalCodeInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutHotelNestedInput {
    @Field(() => AddressCreateWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateWithoutHotelInput)
    create?: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressCreateOrConnectWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutHotelInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutHotelInput>;
    @Field(() => AddressUpsertWithoutHotelInput, {nullable:true})
    @Type(() => AddressUpsertWithoutHotelInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutHotelInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutHotelInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutHotelInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutHotelInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutSchoolNestedInput {
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateWithoutSchoolInput)
    create?: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressCreateOrConnectWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutSchoolInput>;
    @Field(() => AddressUpsertWithoutSchoolInput, {nullable:true})
    @Type(() => AddressUpsertWithoutSchoolInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutSchoolInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutSchoolInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutSchoolInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutSchoolInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutShippingNestedInput {
    @Field(() => AddressCreateWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateWithoutShippingInput)
    create?: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutShippingInput>;
    @Field(() => AddressUpsertWithoutShippingInput, {nullable:true})
    @Type(() => AddressUpsertWithoutShippingInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutShippingInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutShippingInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutShippingInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutShippingInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutUserNestedInput {
    @Field(() => AddressCreateWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateWithoutUserInput)
    create?: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressCreateOrConnectWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutUserInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutUserInput>;
    @Field(() => AddressUpsertWithoutUserInput, {nullable:true})
    @Type(() => AddressUpsertWithoutUserInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutUserInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutUserInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutUserInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutUserInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutHotelInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutHotelInput, {nullable:false})
    @Type(() => AddressUpdateWithoutHotelInput)
    data!: InstanceType<typeof AddressUpdateWithoutHotelInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutSchoolInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSchoolInput)
    data!: InstanceType<typeof AddressUpdateWithoutSchoolInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutShippingInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutShippingInput, {nullable:false})
    @Type(() => AddressUpdateWithoutShippingInput)
    data!: InstanceType<typeof AddressUpdateWithoutShippingInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutUserInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutUserInput, {nullable:false})
    @Type(() => AddressUpdateWithoutUserInput)
    data!: InstanceType<typeof AddressUpdateWithoutUserInput>;
}

@InputType()
export class AddressUpdateWithWhereUniqueWithoutCityInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutCityInput, {nullable:false})
    @Type(() => AddressUpdateWithoutCityInput)
    data!: InstanceType<typeof AddressUpdateWithoutCityInput>;
}

@InputType()
export class AddressUpdateWithWhereUniqueWithoutDistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutDistrictInput, {nullable:false})
    @Type(() => AddressUpdateWithoutDistrictInput)
    data!: InstanceType<typeof AddressUpdateWithoutDistrictInput>;
}

@InputType()
export class AddressUpdateWithWhereUniqueWithoutPostalCodeInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutPostalCodeInput, {nullable:false})
    @Type(() => AddressUpdateWithoutPostalCodeInput)
    data!: InstanceType<typeof AddressUpdateWithoutPostalCodeInput>;
}

@InputType()
export class AddressUpdateWithoutCityInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutDistrictInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutHotelInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutPostalCodeInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutShippingInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => PostalCodeUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpsertWithWhereUniqueWithoutCityInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutCityInput, {nullable:false})
    @Type(() => AddressUpdateWithoutCityInput)
    update!: InstanceType<typeof AddressUpdateWithoutCityInput>;
    @Field(() => AddressCreateWithoutCityInput, {nullable:false})
    @Type(() => AddressCreateWithoutCityInput)
    create!: InstanceType<typeof AddressCreateWithoutCityInput>;
}

@InputType()
export class AddressUpsertWithWhereUniqueWithoutDistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutDistrictInput, {nullable:false})
    @Type(() => AddressUpdateWithoutDistrictInput)
    update!: InstanceType<typeof AddressUpdateWithoutDistrictInput>;
    @Field(() => AddressCreateWithoutDistrictInput, {nullable:false})
    @Type(() => AddressCreateWithoutDistrictInput)
    create!: InstanceType<typeof AddressCreateWithoutDistrictInput>;
}

@InputType()
export class AddressUpsertWithWhereUniqueWithoutPostalCodeInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutPostalCodeInput, {nullable:false})
    @Type(() => AddressUpdateWithoutPostalCodeInput)
    update!: InstanceType<typeof AddressUpdateWithoutPostalCodeInput>;
    @Field(() => AddressCreateWithoutPostalCodeInput, {nullable:false})
    @Type(() => AddressCreateWithoutPostalCodeInput)
    create!: InstanceType<typeof AddressCreateWithoutPostalCodeInput>;
}

@InputType()
export class AddressUpsertWithoutHotelInput {
    @Field(() => AddressUpdateWithoutHotelInput, {nullable:false})
    @Type(() => AddressUpdateWithoutHotelInput)
    update!: InstanceType<typeof AddressUpdateWithoutHotelInput>;
    @Field(() => AddressCreateWithoutHotelInput, {nullable:false})
    @Type(() => AddressCreateWithoutHotelInput)
    create!: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutSchoolInput {
    @Field(() => AddressUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSchoolInput)
    update!: InstanceType<typeof AddressUpdateWithoutSchoolInput>;
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressCreateWithoutSchoolInput)
    create!: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutShippingInput {
    @Field(() => AddressUpdateWithoutShippingInput, {nullable:false})
    @Type(() => AddressUpdateWithoutShippingInput)
    update!: InstanceType<typeof AddressUpdateWithoutShippingInput>;
    @Field(() => AddressCreateWithoutShippingInput, {nullable:false})
    @Type(() => AddressCreateWithoutShippingInput)
    create!: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutUserInput {
    @Field(() => AddressUpdateWithoutUserInput, {nullable:false})
    @Type(() => AddressUpdateWithoutUserInput)
    update!: InstanceType<typeof AddressUpdateWithoutUserInput>;
    @Field(() => AddressCreateWithoutUserInput, {nullable:false})
    @Type(() => AddressCreateWithoutUserInput)
    create!: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [AddressWhereInput], {nullable:true})
    AND?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    OR?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    NOT?: Array<AddressWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFilter>;
    @Field(() => CityRelationFilter, {nullable:true})
    city?: InstanceType<typeof CityRelationFilter>;
    @Field(() => DistrictRelationFilter, {nullable:true})
    district?: InstanceType<typeof DistrictRelationFilter>;
    @Field(() => PostalCodeRelationFilter, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    Shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
}

@InputType()
export class AddressWhereInput {
    @Field(() => [AddressWhereInput], {nullable:true})
    AND?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    OR?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    NOT?: Array<AddressWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    postalCodeId?: InstanceType<typeof IntFilter>;
    @Field(() => CityRelationFilter, {nullable:true})
    city?: InstanceType<typeof CityRelationFilter>;
    @Field(() => DistrictRelationFilter, {nullable:true})
    district?: InstanceType<typeof DistrictRelationFilter>;
    @Field(() => PostalCodeRelationFilter, {nullable:true})
    postalCode?: InstanceType<typeof PostalCodeRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    Shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
}

@ObjectType()
export class Address {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCodeId!: number;
    @Field(() => City, {nullable:false})
    city?: InstanceType<typeof City>;
    @Field(() => District, {nullable:false})
    district?: InstanceType<typeof District>;
    @Field(() => PostalCode, {nullable:false})
    postalCode?: InstanceType<typeof PostalCode>;
    @Field(() => User, {nullable:true})
    user?: InstanceType<typeof User> | null;
    @Field(() => Hotel, {nullable:true})
    hotel?: InstanceType<typeof Hotel> | null;
    @Field(() => School, {nullable:true})
    school?: InstanceType<typeof School> | null;
    @Field(() => Shipping, {nullable:true})
    Shipping?: InstanceType<typeof Shipping> | null;
}

@ObjectType()
export class AggregateAddress {
    @Field(() => AddressCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregate>;
    @Field(() => AddressAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregate>;
    @Field(() => AddressSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregate>;
    @Field(() => AddressMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregate>;
    @Field(() => AddressMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregate>;
}

@ArgsType()
export class CreateManyAddressArgs {
    @Field(() => [AddressCreateManyInput], {nullable:false})
    @Type(() => AddressCreateManyInput)
    data!: Array<AddressCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneAddressArgs {
    @Field(() => AddressCreateInput, {nullable:false})
    @Type(() => AddressCreateInput)
    data!: InstanceType<typeof AddressCreateInput>;
}

@ArgsType()
export class DeleteManyAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@ArgsType()
export class DeleteOneAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstAddressOrThrowArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindFirstAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindManyAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueAddressOrThrowArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyAddressArgs {
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@ArgsType()
export class UpdateOneAddressArgs {
    @Field(() => AddressUpdateInput, {nullable:false})
    @Type(() => AddressUpdateInput)
    data!: InstanceType<typeof AddressUpdateInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateInput, {nullable:false})
    @Type(() => AddressCreateInput)
    create!: InstanceType<typeof AddressCreateInput>;
    @Field(() => AddressUpdateInput, {nullable:false})
    @Type(() => AddressUpdateInput)
    update!: InstanceType<typeof AddressUpdateInput>;
}

@ObjectType()
export class AggregateBank {
    @Field(() => BankCountAggregate, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregate>;
    @Field(() => BankAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregate>;
    @Field(() => BankSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregate>;
    @Field(() => BankMinAggregate, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregate>;
    @Field(() => BankMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregate>;
}

@ArgsType()
export class BankAggregateArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => BankCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregateInput>;
    @Field(() => BankAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregateInput>;
    @Field(() => BankSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregateInput>;
    @Field(() => BankMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregateInput>;
    @Field(() => BankMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregateInput>;
}

@InputType()
export class BankAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class BankAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Float, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class BankCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    logoUrl!: number;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class BankCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
}

@InputType()
export class BankCreateNestedOneWithoutAccountInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class BankCreateOrConnectWithoutAccountInput {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankCreateWithoutAccountInput, {nullable:false})
    @Type(() => BankCreateWithoutAccountInput)
    create!: InstanceType<typeof BankCreateWithoutAccountInput>;
}

@InputType()
export class BankCreateWithoutAccountInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
}

@InputType()
export class BankCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @Field(() => AccountCreateNestedOneWithoutBankAccountInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutBankAccountInput>;
}

@ArgsType()
export class BankGroupByArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithAggregationInput>;
    @Field(() => [BankScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof BankScalarFieldEnum>;
    @Field(() => BankScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof BankScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => BankCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregateInput>;
    @Field(() => BankAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregateInput>;
    @Field(() => BankSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregateInput>;
    @Field(() => BankMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregateInput>;
    @Field(() => BankMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregateInput>;
}

@ObjectType()
export class BankGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => BankCountAggregate, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregate>;
    @Field(() => BankAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregate>;
    @Field(() => BankSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregate>;
    @Field(() => BankMinAggregate, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregate>;
    @Field(() => BankMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregate>;
}

@InputType()
export class BankMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class BankMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    logoUrl?: string;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class BankMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    logoUrl?: string;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankNullableRelationFilter {
    @Field(() => BankWhereInput, {nullable:true})
    is?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    isNot?: InstanceType<typeof BankWhereInput>;
}

@InputType()
export class BankOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => BankCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountOrderByAggregateInput>;
    @Field(() => BankAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgOrderByAggregateInput>;
    @Field(() => BankMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxOrderByAggregateInput>;
    @Field(() => BankMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinOrderByAggregateInput>;
    @Field(() => BankSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumOrderByAggregateInput>;
}

@InputType()
export class BankOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    account?: InstanceType<typeof AccountOrderByWithRelationInput>;
}

@InputType()
export class BankScalarWhereWithAggregatesInput {
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    accountId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class BankSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class BankSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankUncheckedCreateNestedOneWithoutAccountInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class BankUncheckedCreateWithoutAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
}

@InputType()
export class BankUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
}

@InputType()
export class BankUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUncheckedUpdateOneWithoutAccountNestedInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankUpsertWithoutAccountInput, {nullable:true})
    @Type(() => BankUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof BankUpsertWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    disconnect?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    delete?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => BankUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof BankUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class BankUncheckedUpdateWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateOneWithoutAccountNestedInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankUpsertWithoutAccountInput, {nullable:true})
    @Type(() => BankUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof BankUpsertWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    disconnect?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    delete?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => BankUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof BankUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class BankUpdateToOneWithWhereWithoutAccountInput {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankUpdateWithoutAccountInput, {nullable:false})
    @Type(() => BankUpdateWithoutAccountInput)
    data!: InstanceType<typeof BankUpdateWithoutAccountInput>;
}

@InputType()
export class BankUpdateWithoutAccountInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => AccountUpdateOneRequiredWithoutBankAccountNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutBankAccountNestedInput>;
}

@InputType()
export class BankUpsertWithoutAccountInput {
    @Field(() => BankUpdateWithoutAccountInput, {nullable:false})
    @Type(() => BankUpdateWithoutAccountInput)
    update!: InstanceType<typeof BankUpdateWithoutAccountInput>;
    @Field(() => BankCreateWithoutAccountInput, {nullable:false})
    @Type(() => BankCreateWithoutAccountInput)
    create!: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@InputType()
export class BankWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => [BankWhereInput], {nullable:true})
    AND?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    OR?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    NOT?: Array<BankWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@InputType()
export class BankWhereInput {
    @Field(() => [BankWhereInput], {nullable:true})
    AND?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    OR?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    NOT?: Array<BankWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountNumber?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@ObjectType()
export class Bank {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    logoUrl!: string;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Account, {nullable:false})
    account?: InstanceType<typeof Account>;
}

@ArgsType()
export class CreateManyBankArgs {
    @Field(() => [BankCreateManyInput], {nullable:false})
    @Type(() => BankCreateManyInput)
    data!: Array<BankCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneBankArgs {
    @Field(() => BankCreateInput, {nullable:false})
    @Type(() => BankCreateInput)
    data!: InstanceType<typeof BankCreateInput>;
}

@ArgsType()
export class DeleteManyBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@ArgsType()
export class DeleteOneBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindFirstBankOrThrowArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindFirstBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindManyBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueBankOrThrowArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindUniqueBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpdateManyBankArgs {
    @Field(() => BankUpdateManyMutationInput, {nullable:false})
    @Type(() => BankUpdateManyMutationInput)
    data!: InstanceType<typeof BankUpdateManyMutationInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@ArgsType()
export class UpdateOneBankArgs {
    @Field(() => BankUpdateInput, {nullable:false})
    @Type(() => BankUpdateInput)
    data!: InstanceType<typeof BankUpdateInput>;
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpsertOneBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankCreateInput, {nullable:false})
    @Type(() => BankCreateInput)
    create!: InstanceType<typeof BankCreateInput>;
    @Field(() => BankUpdateInput, {nullable:false})
    @Type(() => BankUpdateInput)
    update!: InstanceType<typeof BankUpdateInput>;
}

@ObjectType()
export class AggregateCheckIn {
    @Field(() => CheckInCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregate>;
    @Field(() => CheckInAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregate>;
    @Field(() => CheckInSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregate>;
    @Field(() => CheckInMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregate>;
    @Field(() => CheckInMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregate>;
}

@ArgsType()
export class CheckInAggregateArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CheckInCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregateInput>;
    @Field(() => CheckInAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregateInput>;
    @Field(() => CheckInSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregateInput>;
    @Field(() => CheckInMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregateInput>;
    @Field(() => CheckInMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregateInput>;
}

@InputType()
export class CheckInAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
}

@ObjectType()
export class CheckInAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    hotelId?: number;
}

@InputType()
export class CheckInAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
}

@InputType()
export class CheckInCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class CheckInCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Int, {nullable:false})
    checkInAt!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class CheckInCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInCreateManyHotelInputEnvelope {
    @Field(() => [CheckInCreateManyHotelInput], {nullable:false})
    @Type(() => CheckInCreateManyHotelInput)
    data!: Array<CheckInCreateManyHotelInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CheckInCreateManyHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateManyUserInputEnvelope {
    @Field(() => [CheckInCreateManyUserInput], {nullable:false})
    @Type(() => CheckInCreateManyUserInput)
    data!: Array<CheckInCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CheckInCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateNestedManyWithoutHotelInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInCreateNestedManyWithoutUserInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInCreateOrConnectWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInCreateWithoutHotelInput)
    create!: InstanceType<typeof CheckInCreateWithoutHotelInput>;
}

@InputType()
export class CheckInCreateOrConnectWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateWithoutUserInput, {nullable:false})
    @Type(() => CheckInCreateWithoutUserInput)
    create!: InstanceType<typeof CheckInCreateWithoutUserInput>;
}

@InputType()
export class CheckInCreateWithoutHotelInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutCheckInsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutCheckInsInput>;
}

@InputType()
export class CheckInCreateWithoutUserInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => HotelCreateNestedOneWithoutCheckInsInput, {nullable:false})
    hotel!: InstanceType<typeof HotelCreateNestedOneWithoutCheckInsInput>;
}

@InputType()
export class CheckInCreateInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutCheckInsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutCheckInsInput>;
    @Field(() => HotelCreateNestedOneWithoutCheckInsInput, {nullable:false})
    hotel!: InstanceType<typeof HotelCreateNestedOneWithoutCheckInsInput>;
}

@ArgsType()
export class CheckInGroupByArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithAggregationInput>;
    @Field(() => [CheckInScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof CheckInScalarFieldEnum>;
    @Field(() => CheckInScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof CheckInScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CheckInCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregateInput>;
    @Field(() => CheckInAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregateInput>;
    @Field(() => CheckInSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregateInput>;
    @Field(() => CheckInMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregateInput>;
    @Field(() => CheckInMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregateInput>;
}

@ObjectType()
export class CheckInGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:false})
    checkInAt!: Date | string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => CheckInCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregate>;
    @Field(() => CheckInAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregate>;
    @Field(() => CheckInSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregate>;
    @Field(() => CheckInMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregate>;
    @Field(() => CheckInMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregate>;
}

@InputType()
export class CheckInListRelationFilter {
    @Field(() => CheckInWhereInput, {nullable:true})
    every?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    some?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    none?: InstanceType<typeof CheckInWhereInput>;
}

@InputType()
export class CheckInMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class CheckInMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class CheckInMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class CheckInOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => CheckInCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountOrderByAggregateInput>;
    @Field(() => CheckInAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgOrderByAggregateInput>;
    @Field(() => CheckInMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxOrderByAggregateInput>;
    @Field(() => CheckInMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinOrderByAggregateInput>;
    @Field(() => CheckInSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumOrderByAggregateInput>;
}

@InputType()
export class CheckInOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotel?: InstanceType<typeof HotelOrderByWithRelationInput>;
}

@InputType()
export class CheckInScalarWhereWithAggregatesInput {
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class CheckInScalarWhereInput {
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    AND?: Array<CheckInScalarWhereInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    OR?: Array<CheckInScalarWhereInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    NOT?: Array<CheckInScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class CheckInSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
}

@ObjectType()
export class CheckInSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
}

@InputType()
export class CheckInSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
}

@InputType()
export class CheckInUncheckedCreateNestedManyWithoutHotelInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInUncheckedCreateWithoutHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutHotelNestedInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutHotelInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutHotelInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutHotelInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutHotelInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutHotelInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUpdateManyMutationInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUpdateManyWithWhereWithoutHotelInput {
    @Field(() => CheckInScalarWhereInput, {nullable:false})
    @Type(() => CheckInScalarWhereInput)
    where!: InstanceType<typeof CheckInScalarWhereInput>;
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
}

@InputType()
export class CheckInUpdateManyWithWhereWithoutUserInput {
    @Field(() => CheckInScalarWhereInput, {nullable:false})
    @Type(() => CheckInScalarWhereInput)
    where!: InstanceType<typeof CheckInScalarWhereInput>;
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
}

@InputType()
export class CheckInUpdateManyWithoutHotelNestedInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutHotelInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutHotelInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutHotelInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutHotelInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutHotelInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUpdateManyWithoutUserNestedInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUpdateWithWhereUniqueWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutHotelInput)
    data!: InstanceType<typeof CheckInUpdateWithoutHotelInput>;
}

@InputType()
export class CheckInUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutUserInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutUserInput)
    data!: InstanceType<typeof CheckInUpdateWithoutUserInput>;
}

@InputType()
export class CheckInUpdateWithoutHotelInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpdateWithoutUserInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpdateInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutCheckInsNestedInput>;
    @Field(() => HotelUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpsertWithWhereUniqueWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutHotelInput)
    update!: InstanceType<typeof CheckInUpdateWithoutHotelInput>;
    @Field(() => CheckInCreateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInCreateWithoutHotelInput)
    create!: InstanceType<typeof CheckInCreateWithoutHotelInput>;
}

@InputType()
export class CheckInUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutUserInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutUserInput)
    update!: InstanceType<typeof CheckInUpdateWithoutUserInput>;
    @Field(() => CheckInCreateWithoutUserInput, {nullable:false})
    @Type(() => CheckInCreateWithoutUserInput)
    create!: InstanceType<typeof CheckInCreateWithoutUserInput>;
}

@InputType()
export class CheckInWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [CheckInWhereInput], {nullable:true})
    AND?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    OR?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    NOT?: Array<CheckInWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => HotelRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelRelationFilter>;
}

@InputType()
export class CheckInWhereInput {
    @Field(() => [CheckInWhereInput], {nullable:true})
    AND?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    OR?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    NOT?: Array<CheckInWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => HotelRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelRelationFilter>;
}

@ObjectType()
export class CheckIn {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:false})
    checkInAt!: Date;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => Hotel, {nullable:false})
    hotel?: InstanceType<typeof Hotel>;
}

@ArgsType()
export class CreateManyCheckInArgs {
    @Field(() => [CheckInCreateManyInput], {nullable:false})
    @Type(() => CheckInCreateManyInput)
    data!: Array<CheckInCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCheckInArgs {
    @Field(() => CheckInCreateInput, {nullable:false})
    @Type(() => CheckInCreateInput)
    data!: InstanceType<typeof CheckInCreateInput>;
}

@ArgsType()
export class DeleteManyCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
}

@ArgsType()
export class DeleteOneCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstCheckInOrThrowArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindManyCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCheckInOrThrowArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyCheckInArgs {
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
}

@ArgsType()
export class UpdateOneCheckInArgs {
    @Field(() => CheckInUpdateInput, {nullable:false})
    @Type(() => CheckInUpdateInput)
    data!: InstanceType<typeof CheckInUpdateInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateInput, {nullable:false})
    @Type(() => CheckInCreateInput)
    create!: InstanceType<typeof CheckInCreateInput>;
    @Field(() => CheckInUpdateInput, {nullable:false})
    @Type(() => CheckInUpdateInput)
    update!: InstanceType<typeof CheckInUpdateInput>;
}

@ObjectType()
export class AggregateCity {
    @Field(() => CityCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregate>;
    @Field(() => CityAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregate>;
    @Field(() => CitySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregate>;
    @Field(() => CityMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregate>;
    @Field(() => CityMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregate>;
}

@ArgsType()
export class CityAggregateArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CityCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregateInput>;
    @Field(() => CityAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregateInput>;
    @Field(() => CitySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregateInput>;
    @Field(() => CityMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregateInput>;
    @Field(() => CityMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregateInput>;
}

@InputType()
export class CityAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class CityAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class CityAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class CityCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class CityCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class CityCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@ObjectType()
export class CityCount {
    @Field(() => Int, {nullable:false})
    address?: number;
}

@InputType()
export class CityCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class CityCreateNestedOneWithoutAddressInput {
    @Field(() => CityCreateWithoutAddressInput, {nullable:true})
    @Type(() => CityCreateWithoutAddressInput)
    create?: InstanceType<typeof CityCreateWithoutAddressInput>;
    @Field(() => CityCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => CityCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof CityCreateOrConnectWithoutAddressInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@InputType()
export class CityCreateOrConnectWithoutAddressInput {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityCreateWithoutAddressInput, {nullable:false})
    @Type(() => CityCreateWithoutAddressInput)
    create!: InstanceType<typeof CityCreateWithoutAddressInput>;
}

@InputType()
export class CityCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class CityCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => AddressCreateNestedManyWithoutCityInput, {nullable:true})
    address?: InstanceType<typeof AddressCreateNestedManyWithoutCityInput>;
}

@ArgsType()
export class CityGroupByArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithAggregationInput>;
    @Field(() => [CityScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof CityScalarFieldEnum>;
    @Field(() => CityScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof CityScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CityCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregateInput>;
    @Field(() => CityAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregateInput>;
    @Field(() => CitySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregateInput>;
    @Field(() => CityMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregateInput>;
    @Field(() => CityMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregateInput>;
}

@ObjectType()
export class CityGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => CityCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregate>;
    @Field(() => CityAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregate>;
    @Field(() => CitySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregate>;
    @Field(() => CityMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregate>;
    @Field(() => CityMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregate>;
}

@InputType()
export class CityMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class CityMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class CityMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class CityMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class CityMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class CityMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class CityOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => CityCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountOrderByAggregateInput>;
    @Field(() => CityAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgOrderByAggregateInput>;
    @Field(() => CityMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxOrderByAggregateInput>;
    @Field(() => CityMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinOrderByAggregateInput>;
    @Field(() => CitySumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumOrderByAggregateInput>;
}

@InputType()
export class CityOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => AddressOrderByRelationAggregateInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByRelationAggregateInput>;
}

@InputType()
export class CityRelationFilter {
    @Field(() => CityWhereInput, {nullable:true})
    is?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityWhereInput, {nullable:true})
    isNot?: InstanceType<typeof CityWhereInput>;
}

@InputType()
export class CityScalarWhereWithAggregatesInput {
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class CitySumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class CitySumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class CitySumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class CityUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class CityUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => AddressUncheckedCreateNestedManyWithoutCityInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedCreateNestedManyWithoutCityInput>;
}

@InputType()
export class CityUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUncheckedUpdateManyWithoutCityNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUpdateOneRequiredWithoutAddressNestedInput {
    @Field(() => CityCreateWithoutAddressInput, {nullable:true})
    @Type(() => CityCreateWithoutAddressInput)
    create?: InstanceType<typeof CityCreateWithoutAddressInput>;
    @Field(() => CityCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => CityCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof CityCreateOrConnectWithoutAddressInput>;
    @Field(() => CityUpsertWithoutAddressInput, {nullable:true})
    @Type(() => CityUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof CityUpsertWithoutAddressInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => CityUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof CityUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class CityUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityUpdateWithoutAddressInput, {nullable:false})
    @Type(() => CityUpdateWithoutAddressInput)
    data!: InstanceType<typeof CityUpdateWithoutAddressInput>;
}

@InputType()
export class CityUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateManyWithoutCityNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUpsertWithoutAddressInput {
    @Field(() => CityUpdateWithoutAddressInput, {nullable:false})
    @Type(() => CityUpdateWithoutAddressInput)
    update!: InstanceType<typeof CityUpdateWithoutAddressInput>;
    @Field(() => CityCreateWithoutAddressInput, {nullable:false})
    @Type(() => CityCreateWithoutAddressInput)
    create!: InstanceType<typeof CityCreateWithoutAddressInput>;
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@InputType()
export class CityWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [CityWhereInput], {nullable:true})
    AND?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    OR?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    NOT?: Array<CityWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@InputType()
export class CityWhereInput {
    @Field(() => [CityWhereInput], {nullable:true})
    AND?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    OR?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    NOT?: Array<CityWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@ObjectType()
export class City {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => [Address], {nullable:true})
    address?: Array<Address>;
    @Field(() => CityCount, {nullable:false})
    _count?: InstanceType<typeof CityCount>;
}

@ArgsType()
export class CreateManyCityArgs {
    @Field(() => [CityCreateManyInput], {nullable:false})
    @Type(() => CityCreateManyInput)
    data!: Array<CityCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCityArgs {
    @Field(() => CityCreateInput, {nullable:false})
    @Type(() => CityCreateInput)
    data!: InstanceType<typeof CityCreateInput>;
}

@ArgsType()
export class DeleteManyCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@ArgsType()
export class DeleteOneCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstCityOrThrowArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindManyCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCityOrThrowArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyCityArgs {
    @Field(() => CityUpdateManyMutationInput, {nullable:false})
    @Type(() => CityUpdateManyMutationInput)
    data!: InstanceType<typeof CityUpdateManyMutationInput>;
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@ArgsType()
export class UpdateOneCityArgs {
    @Field(() => CityUpdateInput, {nullable:false})
    @Type(() => CityUpdateInput)
    data!: InstanceType<typeof CityUpdateInput>;
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityCreateInput, {nullable:false})
    @Type(() => CityCreateInput)
    create!: InstanceType<typeof CityCreateInput>;
    @Field(() => CityUpdateInput, {nullable:false})
    @Type(() => CityUpdateInput)
    update!: InstanceType<typeof CityUpdateInput>;
}

@ObjectType()
export class AggregateDistrict {
    @Field(() => DistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregate>;
    @Field(() => DistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregate>;
    @Field(() => DistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregate>;
    @Field(() => DistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregate>;
    @Field(() => DistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregate>;
}

@ArgsType()
export class CreateManyDistrictArgs {
    @Field(() => [DistrictCreateManyInput], {nullable:false})
    @Type(() => DistrictCreateManyInput)
    data!: Array<DistrictCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneDistrictArgs {
    @Field(() => DistrictCreateInput, {nullable:false})
    @Type(() => DistrictCreateInput)
    data!: InstanceType<typeof DistrictCreateInput>;
}

@ArgsType()
export class DeleteManyDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@ArgsType()
export class DeleteOneDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class DistrictAggregateArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => DistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregateInput>;
    @Field(() => DistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregateInput>;
    @Field(() => DistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregateInput>;
    @Field(() => DistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregateInput>;
    @Field(() => DistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregateInput>;
}

@InputType()
export class DistrictAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class DistrictAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class DistrictAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class DistrictCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class DistrictCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class DistrictCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@ObjectType()
export class DistrictCount {
    @Field(() => Int, {nullable:false})
    address?: number;
}

@InputType()
export class DistrictCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class DistrictCreateNestedOneWithoutAddressInput {
    @Field(() => DistrictCreateWithoutAddressInput, {nullable:true})
    @Type(() => DistrictCreateWithoutAddressInput)
    create?: InstanceType<typeof DistrictCreateWithoutAddressInput>;
    @Field(() => DistrictCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof DistrictCreateOrConnectWithoutAddressInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@InputType()
export class DistrictCreateOrConnectWithoutAddressInput {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictCreateWithoutAddressInput, {nullable:false})
    @Type(() => DistrictCreateWithoutAddressInput)
    create!: InstanceType<typeof DistrictCreateWithoutAddressInput>;
}

@InputType()
export class DistrictCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class DistrictCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => AddressCreateNestedManyWithoutDistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressCreateNestedManyWithoutDistrictInput>;
}

@ArgsType()
export class DistrictGroupByArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithAggregationInput>;
    @Field(() => [DistrictScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof DistrictScalarFieldEnum>;
    @Field(() => DistrictScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof DistrictScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => DistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregateInput>;
    @Field(() => DistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregateInput>;
    @Field(() => DistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregateInput>;
    @Field(() => DistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregateInput>;
    @Field(() => DistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregateInput>;
}

@ObjectType()
export class DistrictGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => DistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregate>;
    @Field(() => DistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregate>;
    @Field(() => DistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregate>;
    @Field(() => DistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregate>;
    @Field(() => DistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregate>;
}

@InputType()
export class DistrictMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class DistrictMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class DistrictMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class DistrictMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class DistrictMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class DistrictMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class DistrictOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => DistrictCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountOrderByAggregateInput>;
    @Field(() => DistrictAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgOrderByAggregateInput>;
    @Field(() => DistrictMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxOrderByAggregateInput>;
    @Field(() => DistrictMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinOrderByAggregateInput>;
    @Field(() => DistrictSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumOrderByAggregateInput>;
}

@InputType()
export class DistrictOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => AddressOrderByRelationAggregateInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByRelationAggregateInput>;
}

@InputType()
export class DistrictRelationFilter {
    @Field(() => DistrictWhereInput, {nullable:true})
    is?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    isNot?: InstanceType<typeof DistrictWhereInput>;
}

@InputType()
export class DistrictScalarWhereWithAggregatesInput {
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class DistrictSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class DistrictSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class DistrictSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class DistrictUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class DistrictUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => AddressUncheckedCreateNestedManyWithoutDistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedCreateNestedManyWithoutDistrictInput>;
}

@InputType()
export class DistrictUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUncheckedUpdateManyWithoutDistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUpdateOneRequiredWithoutAddressNestedInput {
    @Field(() => DistrictCreateWithoutAddressInput, {nullable:true})
    @Type(() => DistrictCreateWithoutAddressInput)
    create?: InstanceType<typeof DistrictCreateWithoutAddressInput>;
    @Field(() => DistrictCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof DistrictCreateOrConnectWithoutAddressInput>;
    @Field(() => DistrictUpsertWithoutAddressInput, {nullable:true})
    @Type(() => DistrictUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof DistrictUpsertWithoutAddressInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => DistrictUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof DistrictUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class DistrictUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictUpdateWithoutAddressInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutAddressInput)
    data!: InstanceType<typeof DistrictUpdateWithoutAddressInput>;
}

@InputType()
export class DistrictUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateManyWithoutDistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUpsertWithoutAddressInput {
    @Field(() => DistrictUpdateWithoutAddressInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutAddressInput)
    update!: InstanceType<typeof DistrictUpdateWithoutAddressInput>;
    @Field(() => DistrictCreateWithoutAddressInput, {nullable:false})
    @Type(() => DistrictCreateWithoutAddressInput)
    create!: InstanceType<typeof DistrictCreateWithoutAddressInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@InputType()
export class DistrictWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [DistrictWhereInput], {nullable:true})
    AND?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    OR?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    NOT?: Array<DistrictWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@InputType()
export class DistrictWhereInput {
    @Field(() => [DistrictWhereInput], {nullable:true})
    AND?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    OR?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    NOT?: Array<DistrictWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@ObjectType()
export class District {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => [Address], {nullable:true})
    address?: Array<Address>;
    @Field(() => DistrictCount, {nullable:false})
    _count?: InstanceType<typeof DistrictCount>;
}

@ArgsType()
export class FindFirstDistrictOrThrowArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindFirstDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindManyDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueDistrictOrThrowArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyDistrictArgs {
    @Field(() => DistrictUpdateManyMutationInput, {nullable:false})
    @Type(() => DistrictUpdateManyMutationInput)
    data!: InstanceType<typeof DistrictUpdateManyMutationInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@ArgsType()
export class UpdateOneDistrictArgs {
    @Field(() => DistrictUpdateInput, {nullable:false})
    @Type(() => DistrictUpdateInput)
    data!: InstanceType<typeof DistrictUpdateInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictCreateInput, {nullable:false})
    @Type(() => DistrictCreateInput)
    create!: InstanceType<typeof DistrictCreateInput>;
    @Field(() => DistrictUpdateInput, {nullable:false})
    @Type(() => DistrictUpdateInput)
    update!: InstanceType<typeof DistrictUpdateInput>;
}

@ObjectType()
export class AggregateFaq {
    @Field(() => FaqCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregate>;
    @Field(() => FaqAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregate>;
    @Field(() => FaqSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregate>;
    @Field(() => FaqMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregate>;
    @Field(() => FaqMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregate>;
}

@ArgsType()
export class CreateManyFaqArgs {
    @Field(() => [FaqCreateManyInput], {nullable:false})
    @Type(() => FaqCreateManyInput)
    data!: Array<FaqCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneFaqArgs {
    @Field(() => FaqCreateInput, {nullable:false})
    @Type(() => FaqCreateInput)
    data!: InstanceType<typeof FaqCreateInput>;
}

@ArgsType()
export class DeleteManyFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
}

@ArgsType()
export class DeleteOneFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FaqAggregateArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FaqCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregateInput>;
    @Field(() => FaqAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregateInput>;
    @Field(() => FaqSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregateInput>;
    @Field(() => FaqMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregateInput>;
    @Field(() => FaqMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregateInput>;
}

@InputType()
export class FaqAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class FaqAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class FaqAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class FaqCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class FaqCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class FaqCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FaqCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FaqCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@ArgsType()
export class FaqGroupByArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithAggregationInput>;
    @Field(() => [FaqScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof FaqScalarFieldEnum>;
    @Field(() => FaqScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof FaqScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FaqCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregateInput>;
    @Field(() => FaqAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregateInput>;
    @Field(() => FaqSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregateInput>;
    @Field(() => FaqMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregateInput>;
    @Field(() => FaqMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregateInput>;
}

@ObjectType()
export class FaqGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => FaqCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregate>;
    @Field(() => FaqAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregate>;
    @Field(() => FaqSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregate>;
    @Field(() => FaqMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregate>;
    @Field(() => FaqMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregate>;
}

@InputType()
export class FaqMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FaqMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FaqMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FaqMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FaqMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FaqMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FaqOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => FaqCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountOrderByAggregateInput>;
    @Field(() => FaqAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgOrderByAggregateInput>;
    @Field(() => FaqMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxOrderByAggregateInput>;
    @Field(() => FaqMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinOrderByAggregateInput>;
    @Field(() => FaqSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumOrderByAggregateInput>;
}

@InputType()
export class FaqOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FaqScalarWhereWithAggregatesInput {
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class FaqSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class FaqSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class FaqSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class FaqUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FaqUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [FaqWhereInput], {nullable:true})
    AND?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    OR?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    NOT?: Array<FaqWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class FaqWhereInput {
    @Field(() => [FaqWhereInput], {nullable:true})
    AND?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    OR?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    NOT?: Array<FaqWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@ObjectType()
export class Faq {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
}

@ArgsType()
export class FindFirstFaqOrThrowArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindFirstFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindManyFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueFaqOrThrowArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyFaqArgs {
    @Field(() => FaqUpdateManyMutationInput, {nullable:false})
    @Type(() => FaqUpdateManyMutationInput)
    data!: InstanceType<typeof FaqUpdateManyMutationInput>;
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
}

@ArgsType()
export class UpdateOneFaqArgs {
    @Field(() => FaqUpdateInput, {nullable:false})
    @Type(() => FaqUpdateInput)
    data!: InstanceType<typeof FaqUpdateInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => FaqCreateInput, {nullable:false})
    @Type(() => FaqCreateInput)
    create!: InstanceType<typeof FaqCreateInput>;
    @Field(() => FaqUpdateInput, {nullable:false})
    @Type(() => FaqUpdateInput)
    update!: InstanceType<typeof FaqUpdateInput>;
}

@ObjectType()
export class AggregateFile {
    @Field(() => FileCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregate>;
    @Field(() => FileAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregate>;
    @Field(() => FileSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregate>;
    @Field(() => FileMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregate>;
    @Field(() => FileMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregate>;
}

@ArgsType()
export class CreateManyFileArgs {
    @Field(() => [FileCreateManyInput], {nullable:false})
    @Type(() => FileCreateManyInput)
    data!: Array<FileCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneFileArgs {
    @Field(() => FileCreateInput, {nullable:false})
    @Type(() => FileCreateInput)
    data!: InstanceType<typeof FileCreateInput>;
}

@ArgsType()
export class DeleteManyFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
}

@ArgsType()
export class DeleteOneFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FileAggregateArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FileCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregateInput>;
    @Field(() => FileAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregateInput>;
    @Field(() => FileSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregateInput>;
    @Field(() => FileMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregateInput>;
    @Field(() => FileMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregateInput>;
}

@InputType()
export class FileAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
}

@ObjectType()
export class FileAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
}

@InputType()
export class FileAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
}

@InputType()
export class FileCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class FileCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    fileType!: number;
    @Field(() => Int, {nullable:false})
    filesize!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    url!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class FileCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileCreateManyCreatedByInputEnvelope {
    @Field(() => [FileCreateManyCreatedByInput], {nullable:false})
    @Type(() => FileCreateManyCreatedByInput)
    data!: Array<FileCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class FileCreateManyCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateNestedManyWithoutCreatedByInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class FileCreateOrConnectWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileCreateWithoutCreatedByInput)
    create!: InstanceType<typeof FileCreateWithoutCreatedByInput>;
}

@InputType()
export class FileCreateWithoutCreatedByInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutFilesCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutFilesCreatedInput>;
}

@ArgsType()
export class FileGroupByArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithAggregationInput>;
    @Field(() => [FileScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof FileScalarFieldEnum>;
    @Field(() => FileScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof FileScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FileCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregateInput>;
    @Field(() => FileAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregateInput>;
    @Field(() => FileSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregateInput>;
    @Field(() => FileMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregateInput>;
    @Field(() => FileMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregateInput>;
}

@ObjectType()
export class FileGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => FileCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregate>;
    @Field(() => FileAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregate>;
    @Field(() => FileSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregate>;
    @Field(() => FileMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregate>;
    @Field(() => FileMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregate>;
}

@InputType()
export class FileListRelationFilter {
    @Field(() => FileWhereInput, {nullable:true})
    every?: InstanceType<typeof FileWhereInput>;
    @Field(() => FileWhereInput, {nullable:true})
    some?: InstanceType<typeof FileWhereInput>;
    @Field(() => FileWhereInput, {nullable:true})
    none?: InstanceType<typeof FileWhereInput>;
}

@InputType()
export class FileMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FileMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FileMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class FileOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => FileCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountOrderByAggregateInput>;
    @Field(() => FileAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgOrderByAggregateInput>;
    @Field(() => FileMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxOrderByAggregateInput>;
    @Field(() => FileMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinOrderByAggregateInput>;
    @Field(() => FileSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumOrderByAggregateInput>;
}

@InputType()
export class FileOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class FileScalarWhereWithAggregatesInput {
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumFileTypeWithAggregatesFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    url?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class FileScalarWhereInput {
    @Field(() => [FileScalarWhereInput], {nullable:true})
    AND?: Array<FileScalarWhereInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    OR?: Array<FileScalarWhereInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    NOT?: Array<FileScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class FileSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
}

@ObjectType()
export class FileSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
}

@InputType()
export class FileSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
}

@InputType()
export class FileUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class FileUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [FileUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<FileUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    set?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<FileUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [FileUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<FileUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    @Type(() => FileScalarWhereInput)
    deleteMany?: Array<FileScalarWhereInput>;
}

@InputType()
export class FileUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateManyMutationInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => FileScalarWhereInput, {nullable:false})
    @Type(() => FileScalarWhereInput)
    where!: InstanceType<typeof FileScalarWhereInput>;
    @Field(() => FileUpdateManyMutationInput, {nullable:false})
    @Type(() => FileUpdateManyMutationInput)
    data!: InstanceType<typeof FileUpdateManyMutationInput>;
}

@InputType()
export class FileUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [FileUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<FileUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    set?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<FileUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [FileUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<FileUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    @Type(() => FileScalarWhereInput)
    deleteMany?: Array<FileScalarWhereInput>;
}

@InputType()
export class FileUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof FileUpdateWithoutCreatedByInput>;
}

@InputType()
export class FileUpdateWithoutCreatedByInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutFilesCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutFilesCreatedNestedInput>;
}

@InputType()
export class FileUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof FileUpdateWithoutCreatedByInput>;
    @Field(() => FileCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileCreateWithoutCreatedByInput)
    create!: InstanceType<typeof FileCreateWithoutCreatedByInput>;
}

@InputType()
export class FileWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => [FileWhereInput], {nullable:true})
    AND?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    OR?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    NOT?: Array<FileWhereInput>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class FileWhereInput {
    @Field(() => [FileWhereInput], {nullable:true})
    AND?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    OR?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    NOT?: Array<FileWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class File {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
}

@ArgsType()
export class FindFirstFileOrThrowArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindFirstFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindManyFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueFileOrThrowArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FindUniqueFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class UpdateManyFileArgs {
    @Field(() => FileUpdateManyMutationInput, {nullable:false})
    @Type(() => FileUpdateManyMutationInput)
    data!: InstanceType<typeof FileUpdateManyMutationInput>;
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
}

@ArgsType()
export class UpdateOneFileArgs {
    @Field(() => FileUpdateInput, {nullable:false})
    @Type(() => FileUpdateInput)
    data!: InstanceType<typeof FileUpdateInput>;
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class UpsertOneFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileCreateInput, {nullable:false})
    @Type(() => FileCreateInput)
    create!: InstanceType<typeof FileCreateInput>;
    @Field(() => FileUpdateInput, {nullable:false})
    @Type(() => FileUpdateInput)
    update!: InstanceType<typeof FileUpdateInput>;
}

@ObjectType()
export class AggregateHotel {
    @Field(() => HotelCountAggregate, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregate>;
    @Field(() => HotelAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregate>;
    @Field(() => HotelSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregate>;
    @Field(() => HotelMinAggregate, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregate>;
    @Field(() => HotelMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregate>;
}

@ArgsType()
export class CreateManyHotelArgs {
    @Field(() => [HotelCreateManyInput], {nullable:false})
    @Type(() => HotelCreateManyInput)
    data!: Array<HotelCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneHotelArgs {
    @Field(() => HotelCreateInput, {nullable:false})
    @Type(() => HotelCreateInput)
    data!: InstanceType<typeof HotelCreateInput>;
}

@ArgsType()
export class DeleteManyHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@ArgsType()
export class DeleteOneHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindFirstHotelOrThrowArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindFirstHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindManyHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueHotelOrThrowArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindUniqueHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class HotelAggregateArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => HotelCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregateInput>;
    @Field(() => HotelAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregateInput>;
    @Field(() => HotelSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregateInput>;
    @Field(() => HotelMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregateInput>;
    @Field(() => HotelMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregateInput>;
}

@InputType()
export class HotelAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
}

@ObjectType()
export class HotelAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Float, {nullable:true})
    quota?: number;
}

@InputType()
export class HotelAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
}

@InputType()
export class HotelCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class HotelCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    rating!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class HotelCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class HotelCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    checkIns?: number;
}

@InputType()
export class HotelCreateManyCreatedByInputEnvelope {
    @Field(() => [HotelCreateManyCreatedByInput], {nullable:false})
    @Type(() => HotelCreateManyCreatedByInput)
    data!: Array<HotelCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class HotelCreateManyCreatedByInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class HotelCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdById!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class HotelCreateNestedManyWithoutCreatedByInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
}

@InputType()
export class HotelCreateNestedOneWithoutAddressInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateNestedOneWithoutCheckInsInput {
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create?: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutCheckInsInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateNestedOneWithoutImagesInput {
    @Field(() => HotelCreateWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateWithoutImagesInput)
    create?: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutImagesInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateOrConnectWithoutAddressInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutAddressInput, {nullable:false})
    @Type(() => HotelCreateWithoutAddressInput)
    create!: InstanceType<typeof HotelCreateWithoutAddressInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutCheckInsInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create!: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create!: InstanceType<typeof HotelCreateWithoutCreatedByInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutImagesInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutImagesInput, {nullable:false})
    @Type(() => HotelCreateWithoutImagesInput)
    create!: InstanceType<typeof HotelCreateWithoutImagesInput>;
}

@InputType()
export class HotelCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateWithoutCheckInsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateWithoutCreatedByInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@ArgsType()
export class HotelGroupByArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithAggregationInput>;
    @Field(() => [HotelScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof HotelScalarFieldEnum>;
    @Field(() => HotelScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof HotelScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => HotelCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregateInput>;
    @Field(() => HotelAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregateInput>;
    @Field(() => HotelSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregateInput>;
    @Field(() => HotelMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregateInput>;
    @Field(() => HotelMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregateInput>;
}

@ObjectType()
export class HotelGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    rating!: number;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => HotelCountAggregate, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregate>;
    @Field(() => HotelAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregate>;
    @Field(() => HotelSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregate>;
    @Field(() => HotelMinAggregate, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregate>;
    @Field(() => HotelMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregate>;
}

@InputType()
export class HotelListRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    every?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    some?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    none?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class HotelMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Int, {nullable:true})
    quota?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class HotelMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HotelMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class HotelMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Int, {nullable:true})
    quota?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class HotelMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HotelNullableRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    is?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    isNot?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class HotelOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => HotelCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountOrderByAggregateInput>;
    @Field(() => HotelAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgOrderByAggregateInput>;
    @Field(() => HotelMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxOrderByAggregateInput>;
    @Field(() => HotelMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinOrderByAggregateInput>;
    @Field(() => HotelSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumOrderByAggregateInput>;
}

@InputType()
export class HotelOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => CheckInOrderByRelationAggregateInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInOrderByRelationAggregateInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class HotelRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    is?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    isNot?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelScalarWhereWithAggregatesInput {
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    rating?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    quota?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class HotelScalarWhereInput {
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    AND?: Array<HotelScalarWhereInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    OR?: Array<HotelScalarWhereInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    NOT?: Array<HotelScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class HotelSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
}

@ObjectType()
export class HotelSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Int, {nullable:true})
    quota?: number;
}

@InputType()
export class HotelSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
}

@InputType()
export class HotelUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
}

@InputType()
export class HotelUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutCheckInsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [HotelUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<HotelUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    set?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<HotelUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [HotelUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<HotelUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    @Type(() => HotelScalarWhereInput)
    deleteMany?: Array<HotelScalarWhereInput>;
}

@InputType()
export class HotelUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelUpsertWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutCheckInsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => HotelScalarWhereInput, {nullable:false})
    @Type(() => HotelScalarWhereInput)
    where!: InstanceType<typeof HotelScalarWhereInput>;
    @Field(() => HotelUpdateManyMutationInput, {nullable:false})
    @Type(() => HotelUpdateManyMutationInput)
    data!: InstanceType<typeof HotelUpdateManyMutationInput>;
}

@InputType()
export class HotelUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [HotelUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<HotelUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    set?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<HotelUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [HotelUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<HotelUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    @Type(() => HotelScalarWhereInput)
    deleteMany?: Array<HotelScalarWhereInput>;
}

@InputType()
export class HotelUpdateOneRequiredWithoutCheckInsNestedInput {
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create?: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutCheckInsInput>;
    @Field(() => HotelUpsertWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelUpsertWithoutCheckInsInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutCheckInsInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutCheckInsInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutCheckInsInput>;
}

@InputType()
export class HotelUpdateOneWithoutAddressNestedInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelUpsertWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class HotelUpdateOneWithoutImagesNestedInput {
    @Field(() => HotelCreateWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateWithoutImagesInput)
    create?: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutImagesInput>;
    @Field(() => HotelUpsertWithoutImagesInput, {nullable:true})
    @Type(() => HotelUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutImagesInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutAddressInput, {nullable:false})
    @Type(() => HotelUpdateWithoutAddressInput)
    data!: InstanceType<typeof HotelUpdateWithoutAddressInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutCheckInsInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCheckInsInput)
    data!: InstanceType<typeof HotelUpdateWithoutCheckInsInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutImagesInput, {nullable:false})
    @Type(() => HotelUpdateWithoutImagesInput)
    data!: InstanceType<typeof HotelUpdateWithoutImagesInput>;
}

@InputType()
export class HotelUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof HotelUpdateWithoutCreatedByInput>;
}

@InputType()
export class HotelUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateWithoutCheckInsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateWithoutCreatedByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof HotelUpdateWithoutCreatedByInput>;
    @Field(() => HotelCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create!: InstanceType<typeof HotelCreateWithoutCreatedByInput>;
}

@InputType()
export class HotelUpsertWithoutAddressInput {
    @Field(() => HotelUpdateWithoutAddressInput, {nullable:false})
    @Type(() => HotelUpdateWithoutAddressInput)
    update!: InstanceType<typeof HotelUpdateWithoutAddressInput>;
    @Field(() => HotelCreateWithoutAddressInput, {nullable:false})
    @Type(() => HotelCreateWithoutAddressInput)
    create!: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelUpsertWithoutCheckInsInput {
    @Field(() => HotelUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCheckInsInput)
    update!: InstanceType<typeof HotelUpdateWithoutCheckInsInput>;
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create!: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelUpsertWithoutImagesInput {
    @Field(() => HotelUpdateWithoutImagesInput, {nullable:false})
    @Type(() => HotelUpdateWithoutImagesInput)
    update!: InstanceType<typeof HotelUpdateWithoutImagesInput>;
    @Field(() => HotelCreateWithoutImagesInput, {nullable:false})
    @Type(() => HotelCreateWithoutImagesInput)
    create!: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => [HotelWhereInput], {nullable:true})
    AND?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    OR?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    NOT?: Array<HotelWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class HotelWhereInput {
    @Field(() => [HotelWhereInput], {nullable:true})
    AND?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    OR?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    NOT?: Array<HotelWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class Hotel {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    rating!: number;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [CheckIn], {nullable:true})
    checkIns?: Array<CheckIn>;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
    @Field(() => HotelCount, {nullable:false})
    _count?: InstanceType<typeof HotelCount>;
}

@ArgsType()
export class UpdateManyHotelArgs {
    @Field(() => HotelUpdateManyMutationInput, {nullable:false})
    @Type(() => HotelUpdateManyMutationInput)
    data!: InstanceType<typeof HotelUpdateManyMutationInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@ArgsType()
export class UpdateOneHotelArgs {
    @Field(() => HotelUpdateInput, {nullable:false})
    @Type(() => HotelUpdateInput)
    data!: InstanceType<typeof HotelUpdateInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class UpsertOneHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateInput, {nullable:false})
    @Type(() => HotelCreateInput)
    create!: InstanceType<typeof HotelCreateInput>;
    @Field(() => HotelUpdateInput, {nullable:false})
    @Type(() => HotelUpdateInput)
    update!: InstanceType<typeof HotelUpdateInput>;
}

@ObjectType()
export class AggregateImages {
    @Field(() => ImagesCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregate>;
    @Field(() => ImagesAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregate>;
    @Field(() => ImagesSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregate>;
    @Field(() => ImagesMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregate>;
    @Field(() => ImagesMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregate>;
}

@ArgsType()
export class CreateManyImagesArgs {
    @Field(() => [ImagesCreateManyInput], {nullable:false})
    @Type(() => ImagesCreateManyInput)
    data!: Array<ImagesCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneImagesArgs {
    @Field(() => ImagesCreateInput, {nullable:false})
    @Type(() => ImagesCreateInput)
    data!: InstanceType<typeof ImagesCreateInput>;
}

@ArgsType()
export class DeleteManyImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
}

@ArgsType()
export class DeleteOneImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstImagesOrThrowArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindFirstImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindManyImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueImagesOrThrowArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ImagesAggregateArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ImagesCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregateInput>;
    @Field(() => ImagesAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregateInput>;
    @Field(() => ImagesSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregateInput>;
    @Field(() => ImagesMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregateInput>;
    @Field(() => ImagesMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregateInput>;
}

@InputType()
export class ImagesAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
}

@ObjectType()
export class ImagesAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => Float, {nullable:true})
    hotelImageId?: number;
    @Field(() => Float, {nullable:true})
    programImageId?: number;
    @Field(() => Float, {nullable:true})
    rewardImageId?: number;
    @Field(() => Float, {nullable:true})
    projectImageId?: number;
}

@InputType()
export class ImagesAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
}

@InputType()
export class ImagesCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ImagesCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    fileType!: number;
    @Field(() => Int, {nullable:false})
    filesize!: number;
    @Field(() => Int, {nullable:false})
    url!: number;
    @Field(() => Int, {nullable:false})
    hotelImageId!: number;
    @Field(() => Int, {nullable:false})
    programImageId!: number;
    @Field(() => Int, {nullable:false})
    rewardImageId!: number;
    @Field(() => Int, {nullable:false})
    projectImageId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ImagesCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesCreateManyHotelImageInputEnvelope {
    @Field(() => [ImagesCreateManyHotelImageInput], {nullable:false})
    @Type(() => ImagesCreateManyHotelImageInput)
    data!: Array<ImagesCreateManyHotelImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyHotelImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyProgramImageInputEnvelope {
    @Field(() => [ImagesCreateManyProgramImageInput], {nullable:false})
    @Type(() => ImagesCreateManyProgramImageInput)
    data!: Array<ImagesCreateManyProgramImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyProgramImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyProjectImageInputEnvelope {
    @Field(() => [ImagesCreateManyProjectImageInput], {nullable:false})
    @Type(() => ImagesCreateManyProjectImageInput)
    data!: Array<ImagesCreateManyProjectImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyProjectImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyRewardImageInputEnvelope {
    @Field(() => [ImagesCreateManyRewardImageInput], {nullable:false})
    @Type(() => ImagesCreateManyRewardImageInput)
    data!: Array<ImagesCreateManyRewardImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyRewardImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateNestedManyWithoutHotelImageInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutProgramImageInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutProjectImageInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutRewardImageInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateOrConnectWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutHotelImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProgramImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProjectImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutRewardImageInput>;
}

@InputType()
export class ImagesCreateWithoutHotelImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutProgramImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutProjectImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutRewardImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@ArgsType()
export class ImagesGroupByArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithAggregationInput>;
    @Field(() => [ImagesScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ImagesScalarFieldEnum>;
    @Field(() => ImagesScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ImagesScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ImagesCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregateInput>;
    @Field(() => ImagesAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregateInput>;
    @Field(() => ImagesSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregateInput>;
    @Field(() => ImagesMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregateInput>;
    @Field(() => ImagesMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregateInput>;
}

@ObjectType()
export class ImagesGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => ImagesCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregate>;
    @Field(() => ImagesAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregate>;
    @Field(() => ImagesSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregate>;
    @Field(() => ImagesMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregate>;
    @Field(() => ImagesMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregate>;
}

@InputType()
export class ImagesListRelationFilter {
    @Field(() => ImagesWhereInput, {nullable:true})
    every?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    some?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    none?: InstanceType<typeof ImagesWhereInput>;
}

@InputType()
export class ImagesMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class ImagesMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class ImagesMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ImagesOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    hotelImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    programImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    rewardImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => ImagesCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountOrderByAggregateInput>;
    @Field(() => ImagesAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgOrderByAggregateInput>;
    @Field(() => ImagesMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxOrderByAggregateInput>;
    @Field(() => ImagesMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinOrderByAggregateInput>;
    @Field(() => ImagesSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumOrderByAggregateInput>;
}

@InputType()
export class ImagesOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    hotelImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    programImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    rewardImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelOrderByWithRelationInput>;
    @Field(() => ProgramOrderByWithRelationInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramOrderByWithRelationInput>;
    @Field(() => RewardOrderByWithRelationInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardOrderByWithRelationInput>;
    @Field(() => ProjectOrderByWithRelationInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectOrderByWithRelationInput>;
}

@InputType()
export class ImagesScalarWhereWithAggregatesInput {
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumFileTypeWithAggregatesFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    url?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ImagesScalarWhereInput {
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    AND?: Array<ImagesScalarWhereInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    OR?: Array<ImagesScalarWhereInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    NOT?: Array<ImagesScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ImagesSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
}

@ObjectType()
export class ImagesSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
}

@InputType()
export class ImagesSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutHotelImageInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutProgramImageInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutProjectImageInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutRewardImageInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateWithoutHotelImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutProgramImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutProjectImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutRewardImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutHotelImageNestedInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutHotelImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutHotelImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutHotelImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutHotelImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutHotelImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProgramImageNestedInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProgramImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProgramImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProgramImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProgramImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProgramImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProjectImageNestedInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProjectImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProjectImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProjectImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProjectImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProjectImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutRewardImageNestedInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutRewardImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutRewardImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutRewardImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutRewardImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutRewardImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutHotelImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutProgramImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutProjectImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutRewardImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUpdateManyMutationInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutHotelImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutProgramImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutProjectImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutRewardImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithoutHotelImageNestedInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutHotelImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutHotelImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutHotelImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutHotelImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutProgramImageNestedInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProgramImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProgramImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProgramImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProgramImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutProjectImageNestedInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProjectImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProjectImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProjectImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProjectImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutRewardImageNestedInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutRewardImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutRewardImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutRewardImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutRewardImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutHotelImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutHotelImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProgramImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutProgramImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProjectImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutProjectImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutRewardImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutRewardImageInput>;
}

@InputType()
export class ImagesUpdateWithoutHotelImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutProgramImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutProjectImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutRewardImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutHotelImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutHotelImageInput>;
    @Field(() => ImagesCreateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutHotelImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProgramImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutProgramImageInput>;
    @Field(() => ImagesCreateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProgramImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProjectImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutProjectImageInput>;
    @Field(() => ImagesCreateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProjectImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutRewardImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutRewardImageInput>;
    @Field(() => ImagesCreateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutRewardImageInput>;
}

@InputType()
export class ImagesWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ImagesWhereInput], {nullable:true})
    AND?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    OR?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    NOT?: Array<ImagesWhereInput>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotelImage?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => ProgramNullableRelationFilter, {nullable:true})
    programImage?: InstanceType<typeof ProgramNullableRelationFilter>;
    @Field(() => RewardNullableRelationFilter, {nullable:true})
    rewardImage?: InstanceType<typeof RewardNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectImage?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@InputType()
export class ImagesWhereInput {
    @Field(() => [ImagesWhereInput], {nullable:true})
    AND?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    OR?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    NOT?: Array<ImagesWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotelImage?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => ProgramNullableRelationFilter, {nullable:true})
    programImage?: InstanceType<typeof ProgramNullableRelationFilter>;
    @Field(() => RewardNullableRelationFilter, {nullable:true})
    rewardImage?: InstanceType<typeof RewardNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectImage?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@ObjectType()
export class Images {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId!: number | null;
    @Field(() => Int, {nullable:true})
    programImageId!: number | null;
    @Field(() => Int, {nullable:true})
    rewardImageId!: number | null;
    @Field(() => Int, {nullable:true})
    projectImageId!: number | null;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Hotel, {nullable:true})
    hotelImage?: InstanceType<typeof Hotel> | null;
    @Field(() => Program, {nullable:true})
    programImage?: InstanceType<typeof Program> | null;
    @Field(() => Reward, {nullable:true})
    rewardImage?: InstanceType<typeof Reward> | null;
    @Field(() => Project, {nullable:true})
    projectImage?: InstanceType<typeof Project> | null;
}

@ArgsType()
export class UpdateManyImagesArgs {
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
}

@ArgsType()
export class UpdateOneImagesArgs {
    @Field(() => ImagesUpdateInput, {nullable:false})
    @Type(() => ImagesUpdateInput)
    data!: InstanceType<typeof ImagesUpdateInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateInput, {nullable:false})
    @Type(() => ImagesCreateInput)
    create!: InstanceType<typeof ImagesCreateInput>;
    @Field(() => ImagesUpdateInput, {nullable:false})
    @Type(() => ImagesUpdateInput)
    update!: InstanceType<typeof ImagesUpdateInput>;
}

@ObjectType()
export class AggregateItem {
    @Field(() => ItemCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregate>;
    @Field(() => ItemAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregate>;
    @Field(() => ItemSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregate>;
    @Field(() => ItemMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregate>;
    @Field(() => ItemMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregate>;
}

@ArgsType()
export class CreateManyItemArgs {
    @Field(() => [ItemCreateManyInput], {nullable:false})
    @Type(() => ItemCreateManyInput)
    data!: Array<ItemCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneItemArgs {
    @Field(() => ItemCreateInput, {nullable:false})
    @Type(() => ItemCreateInput)
    data!: InstanceType<typeof ItemCreateInput>;
}

@ArgsType()
export class DeleteManyItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
}

@ArgsType()
export class DeleteOneItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstItemOrThrowArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindFirstItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindManyItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueItemOrThrowArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ItemAggregateArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ItemCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregateInput>;
    @Field(() => ItemAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregateInput>;
    @Field(() => ItemSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregateInput>;
    @Field(() => ItemMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregateInput>;
    @Field(() => ItemMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregateInput>;
}

@InputType()
export class ItemAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    qty?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ItemAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    qty?: number;
    @Field(() => Float, {nullable:true})
    orderId?: number;
}

@InputType()
export class ItemAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ItemCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    qty?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ItemCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    price!: number;
    @Field(() => Int, {nullable:false})
    qty!: number;
    @Field(() => Int, {nullable:false})
    userRole!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ItemCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ItemCreateManyOrderInputEnvelope {
    @Field(() => [ItemCreateManyOrderInput], {nullable:false})
    @Type(() => ItemCreateManyOrderInput)
    data!: Array<ItemCreateManyOrderInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ItemCreateManyOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemCreateNestedManyWithoutOrderInput {
    @Field(() => [ItemCreateWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateWithoutOrderInput)
    create?: Array<ItemCreateWithoutOrderInput>;
    @Field(() => [ItemCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<ItemCreateOrConnectWithoutOrderInput>;
    @Field(() => ItemCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => ItemCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof ItemCreateManyOrderInputEnvelope>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
}

@InputType()
export class ItemCreateOrConnectWithoutOrderInput {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemCreateWithoutOrderInput, {nullable:false})
    @Type(() => ItemCreateWithoutOrderInput)
    create!: InstanceType<typeof ItemCreateWithoutOrderInput>;
}

@InputType()
export class ItemCreateWithoutOrderInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutItemsInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutItemsInput>;
}

@ArgsType()
export class ItemGroupByArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithAggregationInput>;
    @Field(() => [ItemScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ItemScalarFieldEnum>;
    @Field(() => ItemScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ItemScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ItemCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregateInput>;
    @Field(() => ItemAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregateInput>;
    @Field(() => ItemSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregateInput>;
    @Field(() => ItemMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregateInput>;
    @Field(() => ItemMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregateInput>;
}

@ObjectType()
export class ItemGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Int, {nullable:false})
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ItemCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregate>;
    @Field(() => ItemAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregate>;
    @Field(() => ItemSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregate>;
    @Field(() => ItemMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregate>;
    @Field(() => ItemMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregate>;
}

@InputType()
export class ItemListRelationFilter {
    @Field(() => ItemWhereInput, {nullable:true})
    every?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    some?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    none?: InstanceType<typeof ItemWhereInput>;
}

@InputType()
export class ItemMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    qty?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ItemMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Int, {nullable:true})
    qty?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ItemMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    qty?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ItemMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Int, {nullable:true})
    qty?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ItemOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ItemOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ItemCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountOrderByAggregateInput>;
    @Field(() => ItemAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgOrderByAggregateInput>;
    @Field(() => ItemMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxOrderByAggregateInput>;
    @Field(() => ItemMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinOrderByAggregateInput>;
    @Field(() => ItemSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumOrderByAggregateInput>;
}

@InputType()
export class ItemOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    order?: InstanceType<typeof OrderOrderByWithRelationInput>;
}

@InputType()
export class ItemScalarWhereWithAggregatesInput {
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    price?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    qty?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumUserRoleWithAggregatesFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    orderId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ItemScalarWhereInput {
    @Field(() => [ItemScalarWhereInput], {nullable:true})
    AND?: Array<ItemScalarWhereInput>;
    @Field(() => [ItemScalarWhereInput], {nullable:true})
    OR?: Array<ItemScalarWhereInput>;
    @Field(() => [ItemScalarWhereInput], {nullable:true})
    NOT?: Array<ItemScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    qty?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ItemSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    qty?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ItemSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Int, {nullable:true})
    qty?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
}

@InputType()
export class ItemSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    qty?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ItemUncheckedCreateNestedManyWithoutOrderInput {
    @Field(() => [ItemCreateWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateWithoutOrderInput)
    create?: Array<ItemCreateWithoutOrderInput>;
    @Field(() => [ItemCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<ItemCreateOrConnectWithoutOrderInput>;
    @Field(() => ItemCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => ItemCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof ItemCreateManyOrderInputEnvelope>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
}

@InputType()
export class ItemUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemUncheckedUpdateManyWithoutOrderNestedInput {
    @Field(() => [ItemCreateWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateWithoutOrderInput)
    create?: Array<ItemCreateWithoutOrderInput>;
    @Field(() => [ItemCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<ItemCreateOrConnectWithoutOrderInput>;
    @Field(() => [ItemUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<ItemUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => ItemCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => ItemCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof ItemCreateManyOrderInputEnvelope>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<ItemUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [ItemUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<ItemUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [ItemScalarWhereInput], {nullable:true})
    @Type(() => ItemScalarWhereInput)
    deleteMany?: Array<ItemScalarWhereInput>;
}

@InputType()
export class ItemUncheckedUpdateManyWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUpdateManyWithWhereWithoutOrderInput {
    @Field(() => ItemScalarWhereInput, {nullable:false})
    @Type(() => ItemScalarWhereInput)
    where!: InstanceType<typeof ItemScalarWhereInput>;
    @Field(() => ItemUpdateManyMutationInput, {nullable:false})
    @Type(() => ItemUpdateManyMutationInput)
    data!: InstanceType<typeof ItemUpdateManyMutationInput>;
}

@InputType()
export class ItemUpdateManyWithoutOrderNestedInput {
    @Field(() => [ItemCreateWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateWithoutOrderInput)
    create?: Array<ItemCreateWithoutOrderInput>;
    @Field(() => [ItemCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<ItemCreateOrConnectWithoutOrderInput>;
    @Field(() => [ItemUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<ItemUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => ItemCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => ItemCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof ItemCreateManyOrderInputEnvelope>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemWhereUniqueInput], {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ItemWhereUniqueInput, 'id'>>;
    @Field(() => [ItemUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<ItemUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [ItemUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => ItemUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<ItemUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [ItemScalarWhereInput], {nullable:true})
    @Type(() => ItemScalarWhereInput)
    deleteMany?: Array<ItemScalarWhereInput>;
}

@InputType()
export class ItemUpdateWithWhereUniqueWithoutOrderInput {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ItemUpdateWithoutOrderInput)
    data!: InstanceType<typeof ItemUpdateWithoutOrderInput>;
}

@InputType()
export class ItemUpdateWithoutOrderInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    qty?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutItemsNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutItemsNestedInput>;
}

@InputType()
export class ItemUpsertWithWhereUniqueWithoutOrderInput {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ItemUpdateWithoutOrderInput)
    update!: InstanceType<typeof ItemUpdateWithoutOrderInput>;
    @Field(() => ItemCreateWithoutOrderInput, {nullable:false})
    @Type(() => ItemCreateWithoutOrderInput)
    create!: InstanceType<typeof ItemCreateWithoutOrderInput>;
}

@InputType()
export class ItemWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ItemWhereInput], {nullable:true})
    AND?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    OR?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    NOT?: Array<ItemWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    qty?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@InputType()
export class ItemWhereInput {
    @Field(() => [ItemWhereInput], {nullable:true})
    AND?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    OR?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    NOT?: Array<ItemWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    qty?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@ObjectType()
export class Item {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Int, {nullable:false})
    qty!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Order, {nullable:false})
    order?: InstanceType<typeof Order>;
}

@ArgsType()
export class UpdateManyItemArgs {
    @Field(() => ItemUpdateManyMutationInput, {nullable:false})
    @Type(() => ItemUpdateManyMutationInput)
    data!: InstanceType<typeof ItemUpdateManyMutationInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
}

@ArgsType()
export class UpdateOneItemArgs {
    @Field(() => ItemUpdateInput, {nullable:false})
    @Type(() => ItemUpdateInput)
    data!: InstanceType<typeof ItemUpdateInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemCreateInput, {nullable:false})
    @Type(() => ItemCreateInput)
    create!: InstanceType<typeof ItemCreateInput>;
    @Field(() => ItemUpdateInput, {nullable:false})
    @Type(() => ItemUpdateInput)
    update!: InstanceType<typeof ItemUpdateInput>;
}

@ObjectType()
export class AggregateOrder {
    @Field(() => OrderCountAggregate, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregate>;
    @Field(() => OrderAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregate>;
    @Field(() => OrderSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregate>;
    @Field(() => OrderMinAggregate, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregate>;
    @Field(() => OrderMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregate>;
}

@ArgsType()
export class CreateManyOrderArgs {
    @Field(() => [OrderCreateManyInput], {nullable:false})
    @Type(() => OrderCreateManyInput)
    data!: Array<OrderCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneOrderArgs {
    @Field(() => OrderCreateInput, {nullable:false})
    @Type(() => OrderCreateInput)
    data!: InstanceType<typeof OrderCreateInput>;
}

@ArgsType()
export class DeleteManyOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@ArgsType()
export class DeleteOneOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@ArgsType()
export class FindFirstOrderOrThrowArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindFirstOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindManyOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueOrderOrThrowArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@ArgsType()
export class FindUniqueOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@ArgsType()
export class OrderAggregateArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => OrderCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregateInput>;
    @Field(() => OrderAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregateInput>;
    @Field(() => OrderSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregateInput>;
    @Field(() => OrderMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregateInput>;
    @Field(() => OrderMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregateInput>;
}

@InputType()
export class OrderAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
}

@ObjectType()
export class OrderAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
}

@InputType()
export class OrderAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
}

@InputType()
export class OrderCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    isFullPaid?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class OrderCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    orderById!: number;
    @Field(() => Int, {nullable:false})
    shippingId!: number;
    @Field(() => Int, {nullable:false})
    isFullPaid!: number;
    @Field(() => Int, {nullable:false})
    cost!: number;
    @Field(() => Int, {nullable:false})
    platformFee!: number;
    @Field(() => Int, {nullable:false})
    total!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class OrderCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isFullPaid?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class OrderCount {
    @Field(() => Int, {nullable:false})
    items?: number;
    @Field(() => Int, {nullable:false})
    payments?: number;
}

@InputType()
export class OrderCreateManyOrderByInputEnvelope {
    @Field(() => [OrderCreateManyOrderByInput], {nullable:false})
    @Type(() => OrderCreateManyOrderByInput)
    data!: Array<OrderCreateManyOrderByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class OrderCreateManyOrderByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderCreateNestedManyWithoutOrderByInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
}

@InputType()
export class OrderCreateNestedOneWithoutItemsInput {
    @Field(() => OrderCreateWithoutItemsInput, {nullable:true})
    @Type(() => OrderCreateWithoutItemsInput)
    create?: InstanceType<typeof OrderCreateWithoutItemsInput>;
    @Field(() => OrderCreateOrConnectWithoutItemsInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutItemsInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutItemsInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@InputType()
export class OrderCreateNestedOneWithoutPaymentsInput {
    @Field(() => OrderCreateWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderCreateWithoutPaymentsInput)
    create?: InstanceType<typeof OrderCreateWithoutPaymentsInput>;
    @Field(() => OrderCreateOrConnectWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutPaymentsInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutPaymentsInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@InputType()
export class OrderCreateNestedOneWithoutShippingInput {
    @Field(() => OrderCreateWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateWithoutShippingInput)
    create?: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutShippingInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@InputType()
export class OrderCreateOrConnectWithoutItemsInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderCreateWithoutItemsInput, {nullable:false})
    @Type(() => OrderCreateWithoutItemsInput)
    create!: InstanceType<typeof OrderCreateWithoutItemsInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderCreateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderCreateWithoutOrderByInput)
    create!: InstanceType<typeof OrderCreateWithoutOrderByInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutPaymentsInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderCreateWithoutPaymentsInput, {nullable:false})
    @Type(() => OrderCreateWithoutPaymentsInput)
    create!: InstanceType<typeof OrderCreateWithoutPaymentsInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutShippingInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderCreateWithoutShippingInput, {nullable:false})
    @Type(() => OrderCreateWithoutShippingInput)
    create!: InstanceType<typeof OrderCreateWithoutShippingInput>;
}

@InputType()
export class OrderCreateWithoutItemsInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutOrderByInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutPaymentsInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => ItemCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutShippingInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => ItemCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemCreateNestedManyWithoutOrderInput>;
    @Field(() => PaymentCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderCreateInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => ItemCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentCreateNestedManyWithoutOrderInput>;
}

@ArgsType()
export class OrderGroupByArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithAggregationInput>;
    @Field(() => [OrderScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof OrderScalarFieldEnum>;
    @Field(() => OrderScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof OrderScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => OrderCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregateInput>;
    @Field(() => OrderAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregateInput>;
    @Field(() => OrderSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregateInput>;
    @Field(() => OrderMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregateInput>;
    @Field(() => OrderMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregateInput>;
}

@ObjectType()
export class OrderGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => Float, {nullable:false})
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    total!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => OrderCountAggregate, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregate>;
    @Field(() => OrderAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregate>;
    @Field(() => OrderSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregate>;
    @Field(() => OrderMinAggregate, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregate>;
    @Field(() => OrderMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregate>;
}

@InputType()
export class OrderListRelationFilter {
    @Field(() => OrderWhereInput, {nullable:true})
    every?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    some?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    none?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    isFullPaid?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class OrderMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:true})
    isFullPaid?: boolean;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isFullPaid?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class OrderMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    isFullPaid?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class OrderMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:true})
    isFullPaid?: boolean;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isFullPaid?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class OrderOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class OrderOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    shippingId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    isFullPaid?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => OrderCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountOrderByAggregateInput>;
    @Field(() => OrderAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgOrderByAggregateInput>;
    @Field(() => OrderMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxOrderByAggregateInput>;
    @Field(() => OrderMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinOrderByAggregateInput>;
    @Field(() => OrderSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumOrderByAggregateInput>;
}

@InputType()
export class OrderOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    shippingId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    isFullPaid?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    orderBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => ItemOrderByRelationAggregateInput, {nullable:true})
    items?: InstanceType<typeof ItemOrderByRelationAggregateInput>;
    @Field(() => ShippingOrderByWithRelationInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingOrderByWithRelationInput>;
    @Field(() => PaymentOrderByRelationAggregateInput, {nullable:true})
    payments?: InstanceType<typeof PaymentOrderByRelationAggregateInput>;
}

@InputType()
export class OrderRelationFilter {
    @Field(() => OrderWhereInput, {nullable:true})
    is?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    isNot?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderScalarWhereWithAggregatesInput {
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumTransactionStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    orderById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => BoolWithAggregatesFilter, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    cost?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    total?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class OrderScalarWhereInput {
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    AND?: Array<OrderScalarWhereInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    OR?: Array<OrderScalarWhereInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    NOT?: Array<OrderScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringFilter, {nullable:true})
    orderById?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class OrderSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
}

@ObjectType()
export class OrderSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
}

@InputType()
export class OrderSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
}

@InputType()
export class OrderUncheckedCreateNestedManyWithoutOrderByInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
}

@InputType()
export class OrderUncheckedCreateWithoutItemsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutOrderByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutPaymentsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutShippingInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => PaymentUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
    @Field(() => PaymentUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedUpdateManyWithoutOrderByNestedInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => [OrderUpsertWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpsertWithWhereUniqueWithoutOrderByInput)
    upsert?: Array<OrderUpsertWithWhereUniqueWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    set?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderUpdateWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateWithWhereUniqueWithoutOrderByInput)
    update?: Array<OrderUpdateWithWhereUniqueWithoutOrderByInput>;
    @Field(() => [OrderUpdateManyWithWhereWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateManyWithWhereWithoutOrderByInput)
    updateMany?: Array<OrderUpdateManyWithWhereWithoutOrderByInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    @Type(() => OrderScalarWhereInput)
    deleteMany?: Array<OrderScalarWhereInput>;
}

@InputType()
export class OrderUncheckedUpdateManyWithoutOrderByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutItemsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutOrderByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutPaymentsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutShippingInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => PaymentUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUncheckedUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateManyMutationInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUpdateManyWithWhereWithoutOrderByInput {
    @Field(() => OrderScalarWhereInput, {nullable:false})
    @Type(() => OrderScalarWhereInput)
    where!: InstanceType<typeof OrderScalarWhereInput>;
    @Field(() => OrderUpdateManyMutationInput, {nullable:false})
    @Type(() => OrderUpdateManyMutationInput)
    data!: InstanceType<typeof OrderUpdateManyMutationInput>;
}

@InputType()
export class OrderUpdateManyWithoutOrderByNestedInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => [OrderUpsertWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpsertWithWhereUniqueWithoutOrderByInput)
    upsert?: Array<OrderUpsertWithWhereUniqueWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    set?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>>;
    @Field(() => [OrderUpdateWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateWithWhereUniqueWithoutOrderByInput)
    update?: Array<OrderUpdateWithWhereUniqueWithoutOrderByInput>;
    @Field(() => [OrderUpdateManyWithWhereWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateManyWithWhereWithoutOrderByInput)
    updateMany?: Array<OrderUpdateManyWithWhereWithoutOrderByInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    @Type(() => OrderScalarWhereInput)
    deleteMany?: Array<OrderScalarWhereInput>;
}

@InputType()
export class OrderUpdateOneRequiredWithoutItemsNestedInput {
    @Field(() => OrderCreateWithoutItemsInput, {nullable:true})
    @Type(() => OrderCreateWithoutItemsInput)
    create?: InstanceType<typeof OrderCreateWithoutItemsInput>;
    @Field(() => OrderCreateOrConnectWithoutItemsInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutItemsInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutItemsInput>;
    @Field(() => OrderUpsertWithoutItemsInput, {nullable:true})
    @Type(() => OrderUpsertWithoutItemsInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutItemsInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutItemsInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutItemsInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutItemsInput>;
}

@InputType()
export class OrderUpdateOneRequiredWithoutPaymentsNestedInput {
    @Field(() => OrderCreateWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderCreateWithoutPaymentsInput)
    create?: InstanceType<typeof OrderCreateWithoutPaymentsInput>;
    @Field(() => OrderCreateOrConnectWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutPaymentsInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutPaymentsInput>;
    @Field(() => OrderUpsertWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderUpsertWithoutPaymentsInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutPaymentsInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutPaymentsInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutPaymentsInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutPaymentsInput>;
}

@InputType()
export class OrderUpdateOneRequiredWithoutShippingNestedInput {
    @Field(() => OrderCreateWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateWithoutShippingInput)
    create?: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutShippingInput>;
    @Field(() => OrderUpsertWithoutShippingInput, {nullable:true})
    @Type(() => OrderUpsertWithoutShippingInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutShippingInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutShippingInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutShippingInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutShippingInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutItemsInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutItemsInput, {nullable:false})
    @Type(() => OrderUpdateWithoutItemsInput)
    data!: InstanceType<typeof OrderUpdateWithoutItemsInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutPaymentsInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutPaymentsInput, {nullable:false})
    @Type(() => OrderUpdateWithoutPaymentsInput)
    data!: InstanceType<typeof OrderUpdateWithoutPaymentsInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutShippingInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutShippingInput, {nullable:false})
    @Type(() => OrderUpdateWithoutShippingInput)
    data!: InstanceType<typeof OrderUpdateWithoutShippingInput>;
}

@InputType()
export class OrderUpdateWithWhereUniqueWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderUpdateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderUpdateWithoutOrderByInput)
    data!: InstanceType<typeof OrderUpdateWithoutOrderByInput>;
}

@InputType()
export class OrderUpdateWithoutItemsInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutOrderByInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutPaymentsInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => ItemUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutShippingInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => ItemUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUpdateManyWithoutOrderNestedInput>;
    @Field(() => PaymentUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => ItemUpdateManyWithoutOrderNestedInput, {nullable:true})
    items?: InstanceType<typeof ItemUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => PaymentUpdateManyWithoutOrderNestedInput, {nullable:true})
    payments?: InstanceType<typeof PaymentUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpsertWithWhereUniqueWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderUpdateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderUpdateWithoutOrderByInput)
    update!: InstanceType<typeof OrderUpdateWithoutOrderByInput>;
    @Field(() => OrderCreateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderCreateWithoutOrderByInput)
    create!: InstanceType<typeof OrderCreateWithoutOrderByInput>;
}

@InputType()
export class OrderUpsertWithoutItemsInput {
    @Field(() => OrderUpdateWithoutItemsInput, {nullable:false})
    @Type(() => OrderUpdateWithoutItemsInput)
    update!: InstanceType<typeof OrderUpdateWithoutItemsInput>;
    @Field(() => OrderCreateWithoutItemsInput, {nullable:false})
    @Type(() => OrderCreateWithoutItemsInput)
    create!: InstanceType<typeof OrderCreateWithoutItemsInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderUpsertWithoutPaymentsInput {
    @Field(() => OrderUpdateWithoutPaymentsInput, {nullable:false})
    @Type(() => OrderUpdateWithoutPaymentsInput)
    update!: InstanceType<typeof OrderUpdateWithoutPaymentsInput>;
    @Field(() => OrderCreateWithoutPaymentsInput, {nullable:false})
    @Type(() => OrderCreateWithoutPaymentsInput)
    create!: InstanceType<typeof OrderCreateWithoutPaymentsInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderUpsertWithoutShippingInput {
    @Field(() => OrderUpdateWithoutShippingInput, {nullable:false})
    @Type(() => OrderUpdateWithoutShippingInput)
    update!: InstanceType<typeof OrderUpdateWithoutShippingInput>;
    @Field(() => OrderCreateWithoutShippingInput, {nullable:false})
    @Type(() => OrderCreateWithoutShippingInput)
    create!: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => [OrderWhereInput], {nullable:true})
    AND?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    OR?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    NOT?: Array<OrderWhereInput>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    orderBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => ItemListRelationFilter, {nullable:true})
    items?: InstanceType<typeof ItemListRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
    @Field(() => PaymentListRelationFilter, {nullable:true})
    payments?: InstanceType<typeof PaymentListRelationFilter>;
}

@InputType()
export class OrderWhereInput {
    @Field(() => [OrderWhereInput], {nullable:true})
    AND?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    OR?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    NOT?: Array<OrderWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringFilter, {nullable:true})
    orderById?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isFullPaid?: InstanceType<typeof BoolFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    orderBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => ItemListRelationFilter, {nullable:true})
    items?: InstanceType<typeof ItemListRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
    @Field(() => PaymentListRelationFilter, {nullable:true})
    payments?: InstanceType<typeof PaymentListRelationFilter>;
}

@ObjectType()
export class Order {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId!: number | null;
    @Field(() => Boolean, {nullable:false})
    isFullPaid!: boolean;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => Float, {nullable:false})
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    total!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    orderBy?: InstanceType<typeof User>;
    @Field(() => [Item], {nullable:true})
    items?: Array<Item>;
    @Field(() => Shipping, {nullable:true})
    shipping?: InstanceType<typeof Shipping> | null;
    @Field(() => [Payment], {nullable:true})
    payments?: Array<Payment>;
    @Field(() => OrderCount, {nullable:false})
    _count?: InstanceType<typeof OrderCount>;
}

@ArgsType()
export class UpdateManyOrderArgs {
    @Field(() => OrderUpdateManyMutationInput, {nullable:false})
    @Type(() => OrderUpdateManyMutationInput)
    data!: InstanceType<typeof OrderUpdateManyMutationInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@ArgsType()
export class UpdateOneOrderArgs {
    @Field(() => OrderUpdateInput, {nullable:false})
    @Type(() => OrderUpdateInput)
    data!: InstanceType<typeof OrderUpdateInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
}

@ArgsType()
export class UpsertOneOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById'>;
    @Field(() => OrderCreateInput, {nullable:false})
    @Type(() => OrderCreateInput)
    create!: InstanceType<typeof OrderCreateInput>;
    @Field(() => OrderUpdateInput, {nullable:false})
    @Type(() => OrderUpdateInput)
    update!: InstanceType<typeof OrderUpdateInput>;
}

@ObjectType()
export class AggregatePayment {
    @Field(() => PaymentCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PaymentCountAggregate>;
    @Field(() => PaymentAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PaymentAvgAggregate>;
    @Field(() => PaymentSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PaymentSumAggregate>;
    @Field(() => PaymentMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PaymentMinAggregate>;
    @Field(() => PaymentMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PaymentMaxAggregate>;
}

@ArgsType()
export class CreateManyPaymentArgs {
    @Field(() => [PaymentCreateManyInput], {nullable:false})
    @Type(() => PaymentCreateManyInput)
    data!: Array<PaymentCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePaymentArgs {
    @Field(() => PaymentCreateInput, {nullable:false})
    @Type(() => PaymentCreateInput)
    data!: InstanceType<typeof PaymentCreateInput>;
}

@ArgsType()
export class DeleteManyPaymentArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
}

@ArgsType()
export class DeleteOnePaymentArgs {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@ArgsType()
export class FindFirstPaymentOrThrowArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => [PaymentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentOrderByWithRelationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPaymentArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => [PaymentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentOrderByWithRelationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentScalarFieldEnum>;
}

@ArgsType()
export class FindManyPaymentArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => [PaymentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentOrderByWithRelationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePaymentOrThrowArgs {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@ArgsType()
export class FindUniquePaymentArgs {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@ArgsType()
export class PaymentAggregateArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => [PaymentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentOrderByWithRelationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PaymentCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentCountAggregateInput>;
    @Field(() => PaymentAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentAvgAggregateInput>;
    @Field(() => PaymentSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentSumAggregateInput>;
    @Field(() => PaymentMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentMinAggregateInput>;
    @Field(() => PaymentMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentMaxAggregateInput>;
}

@InputType()
export class PaymentAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    totalPayment?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
}

@ObjectType()
export class PaymentAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    totalPayment?: number;
    @Field(() => Float, {nullable:true})
    orderId?: number;
    @Field(() => Float, {nullable:true})
    transactionId?: number;
}

@InputType()
export class PaymentAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
}

@InputType()
export class PaymentCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    totalPayment?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class PaymentCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    adminFee!: number;
    @Field(() => Int, {nullable:false})
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class PaymentCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentCreateManyOrderInputEnvelope {
    @Field(() => [PaymentCreateManyOrderInput], {nullable:false})
    @Type(() => PaymentCreateManyOrderInput)
    data!: Array<PaymentCreateManyOrderInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class PaymentCreateManyOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PaymentCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PaymentCreateNestedManyWithoutOrderInput {
    @Field(() => [PaymentCreateWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateWithoutOrderInput)
    create?: Array<PaymentCreateWithoutOrderInput>;
    @Field(() => [PaymentCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<PaymentCreateOrConnectWithoutOrderInput>;
    @Field(() => PaymentCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => PaymentCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof PaymentCreateManyOrderInputEnvelope>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
}

@InputType()
export class PaymentCreateNestedOneWithoutConfirmationInput {
    @Field(() => PaymentCreateWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentCreateWithoutConfirmationInput)
    create?: InstanceType<typeof PaymentCreateWithoutConfirmationInput>;
    @Field(() => PaymentCreateOrConnectWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutConfirmationInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutConfirmationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@InputType()
export class PaymentCreateNestedOneWithoutTransactionInput {
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create?: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
    @Field(() => PaymentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutTransactionInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@InputType()
export class PaymentCreateOrConnectWithoutConfirmationInput {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentCreateWithoutConfirmationInput, {nullable:false})
    @Type(() => PaymentCreateWithoutConfirmationInput)
    create!: InstanceType<typeof PaymentCreateWithoutConfirmationInput>;
}

@InputType()
export class PaymentCreateOrConnectWithoutOrderInput {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentCreateWithoutOrderInput, {nullable:false})
    @Type(() => PaymentCreateWithoutOrderInput)
    create!: InstanceType<typeof PaymentCreateWithoutOrderInput>;
}

@InputType()
export class PaymentCreateOrConnectWithoutTransactionInput {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:false})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create!: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
}

@InputType()
export class PaymentCreateWithoutConfirmationInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutPaymentsInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutPaymentsInput>;
    @Field(() => TransactionCreateNestedOneWithoutPaymentInput, {nullable:false})
    transaction!: InstanceType<typeof TransactionCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentCreateWithoutOrderInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => TransactionCreateNestedOneWithoutPaymentInput, {nullable:false})
    transaction!: InstanceType<typeof TransactionCreateNestedOneWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentCreateWithoutTransactionInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutPaymentsInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutPaymentsInput>;
    @Field(() => PaymentConfirmationCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutPaymentsInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutPaymentsInput>;
    @Field(() => TransactionCreateNestedOneWithoutPaymentInput, {nullable:false})
    transaction!: InstanceType<typeof TransactionCreateNestedOneWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationCreateNestedOneWithoutPaymentInput>;
}

@ArgsType()
export class PaymentGroupByArgs {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => [PaymentOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<PaymentOrderByWithAggregationInput>;
    @Field(() => [PaymentScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof PaymentScalarFieldEnum>;
    @Field(() => PaymentScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof PaymentScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PaymentCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentCountAggregateInput>;
    @Field(() => PaymentAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentAvgAggregateInput>;
    @Field(() => PaymentSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentSumAggregateInput>;
    @Field(() => PaymentMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentMinAggregateInput>;
    @Field(() => PaymentMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentMaxAggregateInput>;
}

@ObjectType()
export class PaymentGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => PaymentCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PaymentCountAggregate>;
    @Field(() => PaymentAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PaymentAvgAggregate>;
    @Field(() => PaymentSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PaymentSumAggregate>;
    @Field(() => PaymentMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PaymentMinAggregate>;
    @Field(() => PaymentMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PaymentMaxAggregate>;
}

@InputType()
export class PaymentListRelationFilter {
    @Field(() => PaymentWhereInput, {nullable:true})
    every?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    some?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    none?: InstanceType<typeof PaymentWhereInput>;
}

@InputType()
export class PaymentMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    totalPayment?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PaymentMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    totalPayment?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PaymentMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    totalPayment?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PaymentMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    totalPayment?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PaymentMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentNullableRelationFilter {
    @Field(() => PaymentWhereInput, {nullable:true})
    is?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    isNot?: InstanceType<typeof PaymentWhereInput>;
}

@InputType()
export class PaymentOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class PaymentOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => PaymentCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentCountOrderByAggregateInput>;
    @Field(() => PaymentAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentAvgOrderByAggregateInput>;
    @Field(() => PaymentMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentMaxOrderByAggregateInput>;
    @Field(() => PaymentMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentMinOrderByAggregateInput>;
    @Field(() => PaymentSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentSumOrderByAggregateInput>;
}

@InputType()
export class PaymentOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    order?: InstanceType<typeof OrderOrderByWithRelationInput>;
    @Field(() => TransactionOrderByWithRelationInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionOrderByWithRelationInput>;
    @Field(() => PaymentConfirmationOrderByWithRelationInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationOrderByWithRelationInput>;
}

@InputType()
export class PaymentRelationFilter {
    @Field(() => PaymentWhereInput, {nullable:true})
    is?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    isNot?: InstanceType<typeof PaymentWhereInput>;
}

@InputType()
export class PaymentScalarWhereWithAggregatesInput {
    @Field(() => [PaymentScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<PaymentScalarWhereWithAggregatesInput>;
    @Field(() => [PaymentScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<PaymentScalarWhereWithAggregatesInput>;
    @Field(() => [PaymentScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<PaymentScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    totalPayment?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    orderId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class PaymentScalarWhereInput {
    @Field(() => [PaymentScalarWhereInput], {nullable:true})
    AND?: Array<PaymentScalarWhereInput>;
    @Field(() => [PaymentScalarWhereInput], {nullable:true})
    OR?: Array<PaymentScalarWhereInput>;
    @Field(() => [PaymentScalarWhereInput], {nullable:true})
    NOT?: Array<PaymentScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class PaymentSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    totalPayment?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
}

@ObjectType()
export class PaymentSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    totalPayment?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
}

@InputType()
export class PaymentSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    totalPayment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
}

@InputType()
export class PaymentUncheckedCreateNestedManyWithoutOrderInput {
    @Field(() => [PaymentCreateWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateWithoutOrderInput)
    create?: Array<PaymentCreateWithoutOrderInput>;
    @Field(() => [PaymentCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<PaymentCreateOrConnectWithoutOrderInput>;
    @Field(() => PaymentCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => PaymentCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof PaymentCreateManyOrderInputEnvelope>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
}

@InputType()
export class PaymentUncheckedCreateNestedOneWithoutTransactionInput {
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create?: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
    @Field(() => PaymentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutTransactionInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@InputType()
export class PaymentUncheckedCreateWithoutConfirmationInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PaymentUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentUncheckedCreateWithoutTransactionInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput>;
}

@InputType()
export class PaymentUncheckedUpdateManyWithoutOrderNestedInput {
    @Field(() => [PaymentCreateWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateWithoutOrderInput)
    create?: Array<PaymentCreateWithoutOrderInput>;
    @Field(() => [PaymentCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<PaymentCreateOrConnectWithoutOrderInput>;
    @Field(() => [PaymentUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<PaymentUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => PaymentCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => PaymentCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof PaymentCreateManyOrderInputEnvelope>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<PaymentUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [PaymentUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<PaymentUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [PaymentScalarWhereInput], {nullable:true})
    @Type(() => PaymentScalarWhereInput)
    deleteMany?: Array<PaymentScalarWhereInput>;
}

@InputType()
export class PaymentUncheckedUpdateManyWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentUncheckedUpdateOneWithoutTransactionNestedInput {
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create?: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
    @Field(() => PaymentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutTransactionInput>;
    @Field(() => PaymentUpsertWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentUpsertWithoutTransactionInput)
    upsert?: InstanceType<typeof PaymentUpsertWithoutTransactionInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    disconnect?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    delete?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentUpdateToOneWithWhereWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentUpdateToOneWithWhereWithoutTransactionInput)
    update?: InstanceType<typeof PaymentUpdateToOneWithWhereWithoutTransactionInput>;
}

@InputType()
export class PaymentUncheckedUpdateWithoutConfirmationInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUncheckedUpdateWithoutTransactionInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentUpdateManyWithWhereWithoutOrderInput {
    @Field(() => PaymentScalarWhereInput, {nullable:false})
    @Type(() => PaymentScalarWhereInput)
    where!: InstanceType<typeof PaymentScalarWhereInput>;
    @Field(() => PaymentUpdateManyMutationInput, {nullable:false})
    @Type(() => PaymentUpdateManyMutationInput)
    data!: InstanceType<typeof PaymentUpdateManyMutationInput>;
}

@InputType()
export class PaymentUpdateManyWithoutOrderNestedInput {
    @Field(() => [PaymentCreateWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateWithoutOrderInput)
    create?: Array<PaymentCreateWithoutOrderInput>;
    @Field(() => [PaymentCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<PaymentCreateOrConnectWithoutOrderInput>;
    @Field(() => [PaymentUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<PaymentUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => PaymentCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => PaymentCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof PaymentCreateManyOrderInputEnvelope>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentWhereUniqueInput], {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>>;
    @Field(() => [PaymentUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<PaymentUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [PaymentUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => PaymentUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<PaymentUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [PaymentScalarWhereInput], {nullable:true})
    @Type(() => PaymentScalarWhereInput)
    deleteMany?: Array<PaymentScalarWhereInput>;
}

@InputType()
export class PaymentUpdateOneRequiredWithoutConfirmationNestedInput {
    @Field(() => PaymentCreateWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentCreateWithoutConfirmationInput)
    create?: InstanceType<typeof PaymentCreateWithoutConfirmationInput>;
    @Field(() => PaymentCreateOrConnectWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutConfirmationInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutConfirmationInput>;
    @Field(() => PaymentUpsertWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentUpsertWithoutConfirmationInput)
    upsert?: InstanceType<typeof PaymentUpsertWithoutConfirmationInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentUpdateToOneWithWhereWithoutConfirmationInput, {nullable:true})
    @Type(() => PaymentUpdateToOneWithWhereWithoutConfirmationInput)
    update?: InstanceType<typeof PaymentUpdateToOneWithWhereWithoutConfirmationInput>;
}

@InputType()
export class PaymentUpdateOneWithoutTransactionNestedInput {
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create?: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
    @Field(() => PaymentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof PaymentCreateOrConnectWithoutTransactionInput>;
    @Field(() => PaymentUpsertWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentUpsertWithoutTransactionInput)
    upsert?: InstanceType<typeof PaymentUpsertWithoutTransactionInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    disconnect?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    delete?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:true})
    @Type(() => PaymentWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentUpdateToOneWithWhereWithoutTransactionInput, {nullable:true})
    @Type(() => PaymentUpdateToOneWithWhereWithoutTransactionInput)
    update?: InstanceType<typeof PaymentUpdateToOneWithWhereWithoutTransactionInput>;
}

@InputType()
export class PaymentUpdateToOneWithWhereWithoutConfirmationInput {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentUpdateWithoutConfirmationInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutConfirmationInput)
    data!: InstanceType<typeof PaymentUpdateWithoutConfirmationInput>;
}

@InputType()
export class PaymentUpdateToOneWithWhereWithoutTransactionInput {
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
    @Field(() => PaymentUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutTransactionInput)
    data!: InstanceType<typeof PaymentUpdateWithoutTransactionInput>;
}

@InputType()
export class PaymentUpdateWithWhereUniqueWithoutOrderInput {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentUpdateWithoutOrderInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutOrderInput)
    data!: InstanceType<typeof PaymentUpdateWithoutOrderInput>;
}

@InputType()
export class PaymentUpdateWithoutConfirmationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutPaymentsNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutPaymentsNestedInput>;
    @Field(() => TransactionUpdateOneRequiredWithoutPaymentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUpdateOneRequiredWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUpdateWithoutOrderInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => TransactionUpdateOneRequiredWithoutPaymentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUpdateOneRequiredWithoutPaymentNestedInput>;
    @Field(() => PaymentConfirmationUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUpdateWithoutTransactionInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutPaymentsNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutPaymentsNestedInput>;
    @Field(() => PaymentConfirmationUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutPaymentsNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutPaymentsNestedInput>;
    @Field(() => TransactionUpdateOneRequiredWithoutPaymentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUpdateOneRequiredWithoutPaymentNestedInput>;
    @Field(() => PaymentConfirmationUpdateOneWithoutPaymentNestedInput, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationUpdateOneWithoutPaymentNestedInput>;
}

@InputType()
export class PaymentUpsertWithWhereUniqueWithoutOrderInput {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentUpdateWithoutOrderInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutOrderInput)
    update!: InstanceType<typeof PaymentUpdateWithoutOrderInput>;
    @Field(() => PaymentCreateWithoutOrderInput, {nullable:false})
    @Type(() => PaymentCreateWithoutOrderInput)
    create!: InstanceType<typeof PaymentCreateWithoutOrderInput>;
}

@InputType()
export class PaymentUpsertWithoutConfirmationInput {
    @Field(() => PaymentUpdateWithoutConfirmationInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutConfirmationInput)
    update!: InstanceType<typeof PaymentUpdateWithoutConfirmationInput>;
    @Field(() => PaymentCreateWithoutConfirmationInput, {nullable:false})
    @Type(() => PaymentCreateWithoutConfirmationInput)
    create!: InstanceType<typeof PaymentCreateWithoutConfirmationInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
}

@InputType()
export class PaymentUpsertWithoutTransactionInput {
    @Field(() => PaymentUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => PaymentUpdateWithoutTransactionInput)
    update!: InstanceType<typeof PaymentUpdateWithoutTransactionInput>;
    @Field(() => PaymentCreateWithoutTransactionInput, {nullable:false})
    @Type(() => PaymentCreateWithoutTransactionInput)
    create!: InstanceType<typeof PaymentCreateWithoutTransactionInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
}

@InputType()
export class PaymentWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => [PaymentWhereInput], {nullable:true})
    AND?: Array<PaymentWhereInput>;
    @Field(() => [PaymentWhereInput], {nullable:true})
    OR?: Array<PaymentWhereInput>;
    @Field(() => [PaymentWhereInput], {nullable:true})
    NOT?: Array<PaymentWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
    @Field(() => TransactionRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionRelationFilter>;
    @Field(() => PaymentConfirmationNullableRelationFilter, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationNullableRelationFilter>;
}

@InputType()
export class PaymentWhereInput {
    @Field(() => [PaymentWhereInput], {nullable:true})
    AND?: Array<PaymentWhereInput>;
    @Field(() => [PaymentWhereInput], {nullable:true})
    OR?: Array<PaymentWhereInput>;
    @Field(() => [PaymentWhereInput], {nullable:true})
    NOT?: Array<PaymentWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    totalPayment?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
    @Field(() => TransactionRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionRelationFilter>;
    @Field(() => PaymentConfirmationNullableRelationFilter, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmationNullableRelationFilter>;
}

@ObjectType()
export class Payment {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    totalPayment!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Order, {nullable:false})
    order?: InstanceType<typeof Order>;
    @Field(() => Transaction, {nullable:false})
    transaction?: InstanceType<typeof Transaction>;
    @Field(() => PaymentConfirmation, {nullable:true})
    confirmation?: InstanceType<typeof PaymentConfirmation> | null;
}

@ArgsType()
export class UpdateManyPaymentArgs {
    @Field(() => PaymentUpdateManyMutationInput, {nullable:false})
    @Type(() => PaymentUpdateManyMutationInput)
    data!: InstanceType<typeof PaymentUpdateManyMutationInput>;
    @Field(() => PaymentWhereInput, {nullable:true})
    @Type(() => PaymentWhereInput)
    where?: InstanceType<typeof PaymentWhereInput>;
}

@ArgsType()
export class UpdateOnePaymentArgs {
    @Field(() => PaymentUpdateInput, {nullable:false})
    @Type(() => PaymentUpdateInput)
    data!: InstanceType<typeof PaymentUpdateInput>;
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
}

@ArgsType()
export class UpsertOnePaymentArgs {
    @Field(() => PaymentWhereUniqueInput, {nullable:false})
    @Type(() => PaymentWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentWhereUniqueInput, 'id' | 'transactionId'>;
    @Field(() => PaymentCreateInput, {nullable:false})
    @Type(() => PaymentCreateInput)
    create!: InstanceType<typeof PaymentCreateInput>;
    @Field(() => PaymentUpdateInput, {nullable:false})
    @Type(() => PaymentUpdateInput)
    update!: InstanceType<typeof PaymentUpdateInput>;
}

@ObjectType()
export class AggregatePaymentConfirmation {
    @Field(() => PaymentConfirmationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PaymentConfirmationCountAggregate>;
    @Field(() => PaymentConfirmationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PaymentConfirmationAvgAggregate>;
    @Field(() => PaymentConfirmationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PaymentConfirmationSumAggregate>;
    @Field(() => PaymentConfirmationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PaymentConfirmationMinAggregate>;
    @Field(() => PaymentConfirmationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PaymentConfirmationMaxAggregate>;
}

@ArgsType()
export class CreateManyPaymentConfirmationArgs {
    @Field(() => [PaymentConfirmationCreateManyInput], {nullable:false})
    @Type(() => PaymentConfirmationCreateManyInput)
    data!: Array<PaymentConfirmationCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePaymentConfirmationArgs {
    @Field(() => PaymentConfirmationCreateInput, {nullable:false})
    @Type(() => PaymentConfirmationCreateInput)
    data!: InstanceType<typeof PaymentConfirmationCreateInput>;
}

@ArgsType()
export class DeleteManyPaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
}

@ArgsType()
export class DeleteOnePaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@ArgsType()
export class FindFirstPaymentConfirmationOrThrowArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentConfirmationOrderByWithRelationInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentConfirmationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentConfirmationScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentConfirmationOrderByWithRelationInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentConfirmationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentConfirmationScalarFieldEnum>;
}

@ArgsType()
export class FindManyPaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentConfirmationOrderByWithRelationInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PaymentConfirmationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PaymentConfirmationScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePaymentConfirmationOrThrowArgs {
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@ArgsType()
export class FindUniquePaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@ArgsType()
export class PaymentConfirmationAggregateArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PaymentConfirmationOrderByWithRelationInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PaymentConfirmationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentConfirmationCountAggregateInput>;
    @Field(() => PaymentConfirmationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentConfirmationAvgAggregateInput>;
    @Field(() => PaymentConfirmationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentConfirmationSumAggregateInput>;
    @Field(() => PaymentConfirmationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentConfirmationMinAggregateInput>;
    @Field(() => PaymentConfirmationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentConfirmationMaxAggregateInput>;
}

@InputType()
export class PaymentConfirmationAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    paymentId?: true;
}

@ObjectType()
export class PaymentConfirmationAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    paymentId?: number;
}

@InputType()
export class PaymentConfirmationAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
}

@InputType()
export class PaymentConfirmationCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ProofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    paymentId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class PaymentConfirmationCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    ProofUrl!: number;
    @Field(() => Int, {nullable:false})
    paymentId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class PaymentConfirmationCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ProofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentConfirmationCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    ProofUrl!: string;
    @Field(() => Int, {nullable:false})
    paymentId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationCreateNestedOneWithoutPaymentInput {
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create?: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof PaymentConfirmationCreateOrConnectWithoutPaymentInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@InputType()
export class PaymentConfirmationCreateOrConnectWithoutPaymentInput {
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:false})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create!: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
}

@InputType()
export class PaymentConfirmationCreateWithoutPaymentInput {
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    ProofUrl!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    ProofUrl!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => PaymentCreateNestedOneWithoutConfirmationInput, {nullable:false})
    payment!: InstanceType<typeof PaymentCreateNestedOneWithoutConfirmationInput>;
}

@ArgsType()
export class PaymentConfirmationGroupByArgs {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<PaymentConfirmationOrderByWithAggregationInput>;
    @Field(() => [PaymentConfirmationScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof PaymentConfirmationScalarFieldEnum>;
    @Field(() => PaymentConfirmationScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof PaymentConfirmationScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PaymentConfirmationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentConfirmationCountAggregateInput>;
    @Field(() => PaymentConfirmationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentConfirmationAvgAggregateInput>;
    @Field(() => PaymentConfirmationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentConfirmationSumAggregateInput>;
    @Field(() => PaymentConfirmationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentConfirmationMinAggregateInput>;
    @Field(() => PaymentConfirmationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentConfirmationMaxAggregateInput>;
}

@ObjectType()
export class PaymentConfirmationGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    ProofUrl!: string;
    @Field(() => Int, {nullable:false})
    paymentId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => PaymentConfirmationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PaymentConfirmationCountAggregate>;
    @Field(() => PaymentConfirmationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PaymentConfirmationAvgAggregate>;
    @Field(() => PaymentConfirmationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PaymentConfirmationSumAggregate>;
    @Field(() => PaymentConfirmationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PaymentConfirmationMinAggregate>;
    @Field(() => PaymentConfirmationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PaymentConfirmationMaxAggregate>;
}

@InputType()
export class PaymentConfirmationMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ProofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    paymentId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class PaymentConfirmationMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    ProofUrl?: string;
    @Field(() => Int, {nullable:true})
    paymentId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ProofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentConfirmationMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ProofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    paymentId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class PaymentConfirmationMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    ProofUrl?: string;
    @Field(() => Int, {nullable:true})
    paymentId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ProofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class PaymentConfirmationNullableRelationFilter {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    is?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    isNot?: InstanceType<typeof PaymentConfirmationWhereInput>;
}

@InputType()
export class PaymentConfirmationOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ProofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => PaymentConfirmationCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PaymentConfirmationCountOrderByAggregateInput>;
    @Field(() => PaymentConfirmationAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PaymentConfirmationAvgOrderByAggregateInput>;
    @Field(() => PaymentConfirmationMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PaymentConfirmationMaxOrderByAggregateInput>;
    @Field(() => PaymentConfirmationMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PaymentConfirmationMinOrderByAggregateInput>;
    @Field(() => PaymentConfirmationSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PaymentConfirmationSumOrderByAggregateInput>;
}

@InputType()
export class PaymentConfirmationOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ProofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => PaymentOrderByWithRelationInput, {nullable:true})
    payment?: InstanceType<typeof PaymentOrderByWithRelationInput>;
}

@InputType()
export class PaymentConfirmationScalarWhereWithAggregatesInput {
    @Field(() => [PaymentConfirmationScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<PaymentConfirmationScalarWhereWithAggregatesInput>;
    @Field(() => [PaymentConfirmationScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<PaymentConfirmationScalarWhereWithAggregatesInput>;
    @Field(() => [PaymentConfirmationScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<PaymentConfirmationScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    ProofUrl?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    paymentId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class PaymentConfirmationSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    paymentId?: true;
}

@ObjectType()
export class PaymentConfirmationSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    paymentId?: number;
}

@InputType()
export class PaymentConfirmationSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    paymentId?: keyof typeof SortOrder;
}

@InputType()
export class PaymentConfirmationUncheckedCreateNestedOneWithoutPaymentInput {
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create?: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof PaymentConfirmationCreateOrConnectWithoutPaymentInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@InputType()
export class PaymentConfirmationUncheckedCreateWithoutPaymentInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    ProofUrl!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    ProofUrl!: string;
    @Field(() => Int, {nullable:false})
    paymentId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class PaymentConfirmationUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    paymentId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentConfirmationUncheckedUpdateOneWithoutPaymentNestedInput {
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create?: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof PaymentConfirmationCreateOrConnectWithoutPaymentInput>;
    @Field(() => PaymentConfirmationUpsertWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationUpsertWithoutPaymentInput)
    upsert?: InstanceType<typeof PaymentConfirmationUpsertWithoutPaymentInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    disconnect?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    delete?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput)
    update?: InstanceType<typeof PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput>;
}

@InputType()
export class PaymentConfirmationUncheckedUpdateWithoutPaymentInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentConfirmationUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    paymentId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentConfirmationUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentConfirmationUpdateOneWithoutPaymentNestedInput {
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create?: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof PaymentConfirmationCreateOrConnectWithoutPaymentInput>;
    @Field(() => PaymentConfirmationUpsertWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationUpsertWithoutPaymentInput)
    upsert?: InstanceType<typeof PaymentConfirmationUpsertWithoutPaymentInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    disconnect?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    delete?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    connect?: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput, {nullable:true})
    @Type(() => PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput)
    update?: InstanceType<typeof PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput>;
}

@InputType()
export class PaymentConfirmationUpdateToOneWithWhereWithoutPaymentInput {
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
    @Field(() => PaymentConfirmationUpdateWithoutPaymentInput, {nullable:false})
    @Type(() => PaymentConfirmationUpdateWithoutPaymentInput)
    data!: InstanceType<typeof PaymentConfirmationUpdateWithoutPaymentInput>;
}

@InputType()
export class PaymentConfirmationUpdateWithoutPaymentInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PaymentConfirmationUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentUpdateOneRequiredWithoutConfirmationNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUpdateOneRequiredWithoutConfirmationNestedInput>;
}

@InputType()
export class PaymentConfirmationUpsertWithoutPaymentInput {
    @Field(() => PaymentConfirmationUpdateWithoutPaymentInput, {nullable:false})
    @Type(() => PaymentConfirmationUpdateWithoutPaymentInput)
    update!: InstanceType<typeof PaymentConfirmationUpdateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationCreateWithoutPaymentInput, {nullable:false})
    @Type(() => PaymentConfirmationCreateWithoutPaymentInput)
    create!: InstanceType<typeof PaymentConfirmationCreateWithoutPaymentInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
}

@InputType()
export class PaymentConfirmationWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    paymentId?: number;
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    AND?: Array<PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    OR?: Array<PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    NOT?: Array<PaymentConfirmationWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => PaymentRelationFilter, {nullable:true})
    payment?: InstanceType<typeof PaymentRelationFilter>;
}

@InputType()
export class PaymentConfirmationWhereInput {
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    AND?: Array<PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    OR?: Array<PaymentConfirmationWhereInput>;
    @Field(() => [PaymentConfirmationWhereInput], {nullable:true})
    NOT?: Array<PaymentConfirmationWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    ProofUrl?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    paymentId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => PaymentRelationFilter, {nullable:true})
    payment?: InstanceType<typeof PaymentRelationFilter>;
}

@ObjectType()
export class PaymentConfirmation {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    ProofUrl!: string;
    @Field(() => Int, {nullable:false})
    paymentId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Payment, {nullable:false})
    payment?: InstanceType<typeof Payment>;
}

@ArgsType()
export class UpdateManyPaymentConfirmationArgs {
    @Field(() => PaymentConfirmationUpdateManyMutationInput, {nullable:false})
    @Type(() => PaymentConfirmationUpdateManyMutationInput)
    data!: InstanceType<typeof PaymentConfirmationUpdateManyMutationInput>;
    @Field(() => PaymentConfirmationWhereInput, {nullable:true})
    @Type(() => PaymentConfirmationWhereInput)
    where?: InstanceType<typeof PaymentConfirmationWhereInput>;
}

@ArgsType()
export class UpdateOnePaymentConfirmationArgs {
    @Field(() => PaymentConfirmationUpdateInput, {nullable:false})
    @Type(() => PaymentConfirmationUpdateInput)
    data!: InstanceType<typeof PaymentConfirmationUpdateInput>;
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
}

@ArgsType()
export class UpsertOnePaymentConfirmationArgs {
    @Field(() => PaymentConfirmationWhereUniqueInput, {nullable:false})
    @Type(() => PaymentConfirmationWhereUniqueInput)
    where!: Prisma.AtLeast<PaymentConfirmationWhereUniqueInput, 'id' | 'paymentId'>;
    @Field(() => PaymentConfirmationCreateInput, {nullable:false})
    @Type(() => PaymentConfirmationCreateInput)
    create!: InstanceType<typeof PaymentConfirmationCreateInput>;
    @Field(() => PaymentConfirmationUpdateInput, {nullable:false})
    @Type(() => PaymentConfirmationUpdateInput)
    update!: InstanceType<typeof PaymentConfirmationUpdateInput>;
}

@ObjectType()
export class AggregatePointTransaction {
    @Field(() => PointTransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregate>;
    @Field(() => PointTransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregate>;
    @Field(() => PointTransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregate>;
    @Field(() => PointTransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregate>;
    @Field(() => PointTransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregate>;
}

@ArgsType()
export class CreateManyPointTransactionArgs {
    @Field(() => [PointTransactionCreateManyInput], {nullable:false})
    @Type(() => PointTransactionCreateManyInput)
    data!: Array<PointTransactionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePointTransactionArgs {
    @Field(() => PointTransactionCreateInput, {nullable:false})
    @Type(() => PointTransactionCreateInput)
    data!: InstanceType<typeof PointTransactionCreateInput>;
}

@ArgsType()
export class DeleteManyPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
}

@ArgsType()
export class DeleteOnePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstPointTransactionOrThrowArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindManyPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePointTransactionOrThrowArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniquePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class PointTransactionAggregateArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PointTransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregateInput>;
    @Field(() => PointTransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregateInput>;
    @Field(() => PointTransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregateInput>;
    @Field(() => PointTransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregateInput>;
    @Field(() => PointTransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregateInput>;
}

@InputType()
export class PointTransactionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
}

@ObjectType()
export class PointTransactionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
}

@InputType()
export class PointTransactionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class PointTransactionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    pointType!: number;
    @Field(() => Int, {nullable:false})
    transactionType!: number;
    @Field(() => Int, {nullable:false})
    currentBalance!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class PointTransactionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionCreateManyUserInputEnvelope {
    @Field(() => [PointTransactionCreateManyUserInput], {nullable:false})
    @Type(() => PointTransactionCreateManyUserInput)
    data!: Array<PointTransactionCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class PointTransactionCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateNestedManyWithoutUserInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
}

@InputType()
export class PointTransactionCreateOrConnectWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create!: InstanceType<typeof PointTransactionCreateWithoutUserInput>;
}

@InputType()
export class PointTransactionCreateWithoutUserInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutPointTransactionsInput, {nullable:false})
    User!: InstanceType<typeof UserCreateNestedOneWithoutPointTransactionsInput>;
}

@ArgsType()
export class PointTransactionGroupByArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithAggregationInput>;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof PointTransactionScalarFieldEnum>;
    @Field(() => PointTransactionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PointTransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregateInput>;
    @Field(() => PointTransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregateInput>;
    @Field(() => PointTransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregateInput>;
    @Field(() => PointTransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregateInput>;
    @Field(() => PointTransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregateInput>;
}

@ObjectType()
export class PointTransactionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => PointTransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregate>;
    @Field(() => PointTransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregate>;
    @Field(() => PointTransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregate>;
    @Field(() => PointTransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregate>;
    @Field(() => PointTransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregate>;
}

@InputType()
export class PointTransactionListRelationFilter {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    every?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    some?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    none?: InstanceType<typeof PointTransactionWhereInput>;
}

@InputType()
export class PointTransactionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PointTransactionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => PointType, {nullable:true})
    pointType?: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PointTransactionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => PointType, {nullable:true})
    pointType?: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => PointTransactionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountOrderByAggregateInput>;
    @Field(() => PointTransactionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgOrderByAggregateInput>;
    @Field(() => PointTransactionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxOrderByAggregateInput>;
    @Field(() => PointTransactionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinOrderByAggregateInput>;
    @Field(() => PointTransactionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumOrderByAggregateInput>;
}

@InputType()
export class PointTransactionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    User?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class PointTransactionScalarWhereWithAggregatesInput {
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => EnumPointTypeWithAggregatesFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeWithAggregatesFilter>;
    @Field(() => EnumTransactionTypeWithAggregatesFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class PointTransactionScalarWhereInput {
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    AND?: Array<PointTransactionScalarWhereInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    OR?: Array<PointTransactionScalarWhereInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    NOT?: Array<PointTransactionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class PointTransactionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
}

@ObjectType()
export class PointTransactionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
}

@InputType()
export class PointTransactionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
}

@InputType()
export class PointTransactionUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [PointTransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<PointTransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<PointTransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [PointTransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<PointTransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    @Type(() => PointTransactionScalarWhereInput)
    deleteMany?: Array<PointTransactionScalarWhereInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateManyWithWhereWithoutUserInput {
    @Field(() => PointTransactionScalarWhereInput, {nullable:false})
    @Type(() => PointTransactionScalarWhereInput)
    where!: InstanceType<typeof PointTransactionScalarWhereInput>;
    @Field(() => PointTransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => PointTransactionUpdateManyMutationInput)
    data!: InstanceType<typeof PointTransactionUpdateManyMutationInput>;
}

@InputType()
export class PointTransactionUpdateManyWithoutUserNestedInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [PointTransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<PointTransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<PointTransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [PointTransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<PointTransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    @Type(() => PointTransactionScalarWhereInput)
    deleteMany?: Array<PointTransactionScalarWhereInput>;
}

@InputType()
export class PointTransactionUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionUpdateWithoutUserInput)
    data!: InstanceType<typeof PointTransactionUpdateWithoutUserInput>;
}

@InputType()
export class PointTransactionUpdateWithoutUserInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutPointTransactionsNestedInput, {nullable:true})
    User?: InstanceType<typeof UserUpdateOneRequiredWithoutPointTransactionsNestedInput>;
}

@InputType()
export class PointTransactionUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionUpdateWithoutUserInput)
    update!: InstanceType<typeof PointTransactionUpdateWithoutUserInput>;
    @Field(() => PointTransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create!: InstanceType<typeof PointTransactionCreateWithoutUserInput>;
}

@InputType()
export class PointTransactionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    AND?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    OR?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    NOT?: Array<PointTransactionWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class PointTransactionWhereInput {
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    AND?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    OR?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    NOT?: Array<PointTransactionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class PointTransaction {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:false,defaultValue:0})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => User, {nullable:false})
    User?: InstanceType<typeof User>;
}

@ArgsType()
export class UpdateManyPointTransactionArgs {
    @Field(() => PointTransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => PointTransactionUpdateManyMutationInput)
    data!: InstanceType<typeof PointTransactionUpdateManyMutationInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
}

@ArgsType()
export class UpdateOnePointTransactionArgs {
    @Field(() => PointTransactionUpdateInput, {nullable:false})
    @Type(() => PointTransactionUpdateInput)
    data!: InstanceType<typeof PointTransactionUpdateInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOnePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionCreateInput, {nullable:false})
    @Type(() => PointTransactionCreateInput)
    create!: InstanceType<typeof PointTransactionCreateInput>;
    @Field(() => PointTransactionUpdateInput, {nullable:false})
    @Type(() => PointTransactionUpdateInput)
    update!: InstanceType<typeof PointTransactionUpdateInput>;
}

@ObjectType()
export class AggregatePostalCode {
    @Field(() => PostalCodeCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PostalCodeCountAggregate>;
    @Field(() => PostalCodeAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PostalCodeAvgAggregate>;
    @Field(() => PostalCodeSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PostalCodeSumAggregate>;
    @Field(() => PostalCodeMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PostalCodeMinAggregate>;
    @Field(() => PostalCodeMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PostalCodeMaxAggregate>;
}

@ArgsType()
export class CreateManyPostalCodeArgs {
    @Field(() => [PostalCodeCreateManyInput], {nullable:false})
    @Type(() => PostalCodeCreateManyInput)
    data!: Array<PostalCodeCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePostalCodeArgs {
    @Field(() => PostalCodeCreateInput, {nullable:false})
    @Type(() => PostalCodeCreateInput)
    data!: InstanceType<typeof PostalCodeCreateInput>;
}

@ArgsType()
export class DeleteManyPostalCodeArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
}

@ArgsType()
export class DeleteOnePostalCodeArgs {
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
}

@ArgsType()
export class FindFirstPostalCodeOrThrowArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => [PostalCodeOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PostalCodeOrderByWithRelationInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PostalCodeScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PostalCodeScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPostalCodeArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => [PostalCodeOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PostalCodeOrderByWithRelationInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PostalCodeScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PostalCodeScalarFieldEnum>;
}

@ArgsType()
export class FindManyPostalCodeArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => [PostalCodeOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PostalCodeOrderByWithRelationInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PostalCodeScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PostalCodeScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePostalCodeOrThrowArgs {
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
}

@ArgsType()
export class FindUniquePostalCodeArgs {
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
}

@ArgsType()
export class PostalCodeAggregateArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => [PostalCodeOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PostalCodeOrderByWithRelationInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PostalCodeCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PostalCodeCountAggregateInput>;
    @Field(() => PostalCodeAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PostalCodeAvgAggregateInput>;
    @Field(() => PostalCodeSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PostalCodeSumAggregateInput>;
    @Field(() => PostalCodeMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PostalCodeMinAggregateInput>;
    @Field(() => PostalCodeMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PostalCodeMaxAggregateInput>;
}

@InputType()
export class PostalCodeAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    code?: true;
}

@ObjectType()
export class PostalCodeAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    code?: number;
}

@InputType()
export class PostalCodeAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
}

@InputType()
export class PostalCodeCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    code?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class PostalCodeCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    code!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class PostalCodeCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
}

@ObjectType()
export class PostalCodeCount {
    @Field(() => Int, {nullable:false})
    address?: number;
}

@InputType()
export class PostalCodeCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code!: number;
}

@InputType()
export class PostalCodeCreateNestedOneWithoutAddressInput {
    @Field(() => PostalCodeCreateWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeCreateWithoutAddressInput)
    create?: InstanceType<typeof PostalCodeCreateWithoutAddressInput>;
    @Field(() => PostalCodeCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof PostalCodeCreateOrConnectWithoutAddressInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    @Type(() => PostalCodeWhereUniqueInput)
    connect?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
}

@InputType()
export class PostalCodeCreateOrConnectWithoutAddressInput {
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => PostalCodeCreateWithoutAddressInput, {nullable:false})
    @Type(() => PostalCodeCreateWithoutAddressInput)
    create!: InstanceType<typeof PostalCodeCreateWithoutAddressInput>;
}

@InputType()
export class PostalCodeCreateWithoutAddressInput {
    @Field(() => Int, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code!: number;
}

@InputType()
export class PostalCodeCreateInput {
    @Field(() => Int, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code!: number;
    @Field(() => AddressCreateNestedManyWithoutPostalCodeInput, {nullable:true})
    address?: InstanceType<typeof AddressCreateNestedManyWithoutPostalCodeInput>;
}

@ArgsType()
export class PostalCodeGroupByArgs {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => [PostalCodeOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<PostalCodeOrderByWithAggregationInput>;
    @Field(() => [PostalCodeScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof PostalCodeScalarFieldEnum>;
    @Field(() => PostalCodeScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof PostalCodeScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PostalCodeCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PostalCodeCountAggregateInput>;
    @Field(() => PostalCodeAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PostalCodeAvgAggregateInput>;
    @Field(() => PostalCodeSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PostalCodeSumAggregateInput>;
    @Field(() => PostalCodeMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PostalCodeMinAggregateInput>;
    @Field(() => PostalCodeMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PostalCodeMaxAggregateInput>;
}

@ObjectType()
export class PostalCodeGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    code!: number;
    @Field(() => PostalCodeCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PostalCodeCountAggregate>;
    @Field(() => PostalCodeAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PostalCodeAvgAggregate>;
    @Field(() => PostalCodeSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PostalCodeSumAggregate>;
    @Field(() => PostalCodeMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PostalCodeMinAggregate>;
    @Field(() => PostalCodeMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PostalCodeMaxAggregate>;
}

@InputType()
export class PostalCodeMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    code?: true;
}

@ObjectType()
export class PostalCodeMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    code?: number;
}

@InputType()
export class PostalCodeMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
}

@InputType()
export class PostalCodeMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    code?: true;
}

@ObjectType()
export class PostalCodeMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    code?: number;
}

@InputType()
export class PostalCodeMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
}

@InputType()
export class PostalCodeOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
    @Field(() => PostalCodeCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PostalCodeCountOrderByAggregateInput>;
    @Field(() => PostalCodeAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PostalCodeAvgOrderByAggregateInput>;
    @Field(() => PostalCodeMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PostalCodeMaxOrderByAggregateInput>;
    @Field(() => PostalCodeMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PostalCodeMinOrderByAggregateInput>;
    @Field(() => PostalCodeSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PostalCodeSumOrderByAggregateInput>;
}

@InputType()
export class PostalCodeOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
    @Field(() => AddressOrderByRelationAggregateInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByRelationAggregateInput>;
}

@InputType()
export class PostalCodeRelationFilter {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    is?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => PostalCodeWhereInput, {nullable:true})
    isNot?: InstanceType<typeof PostalCodeWhereInput>;
}

@InputType()
export class PostalCodeScalarWhereWithAggregatesInput {
    @Field(() => [PostalCodeScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<PostalCodeScalarWhereWithAggregatesInput>;
    @Field(() => [PostalCodeScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<PostalCodeScalarWhereWithAggregatesInput>;
    @Field(() => [PostalCodeScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<PostalCodeScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    code?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class PostalCodeSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    code?: true;
}

@ObjectType()
export class PostalCodeSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    code?: number;
}

@InputType()
export class PostalCodeSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    code?: keyof typeof SortOrder;
}

@InputType()
export class PostalCodeUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code!: number;
}

@InputType()
export class PostalCodeUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code!: number;
    @Field(() => AddressUncheckedCreateNestedManyWithoutPostalCodeInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedCreateNestedManyWithoutPostalCodeInput>;
}

@InputType()
export class PostalCodeUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class PostalCodeUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class PostalCodeUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => AddressUncheckedUpdateManyWithoutPostalCodeNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedUpdateManyWithoutPostalCodeNestedInput>;
}

@InputType()
export class PostalCodeUpdateManyMutationInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class PostalCodeUpdateOneRequiredWithoutAddressNestedInput {
    @Field(() => PostalCodeCreateWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeCreateWithoutAddressInput)
    create?: InstanceType<typeof PostalCodeCreateWithoutAddressInput>;
    @Field(() => PostalCodeCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof PostalCodeCreateOrConnectWithoutAddressInput>;
    @Field(() => PostalCodeUpsertWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof PostalCodeUpsertWithoutAddressInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:true})
    @Type(() => PostalCodeWhereUniqueInput)
    connect?: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => PostalCodeUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => PostalCodeUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof PostalCodeUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class PostalCodeUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
    @Field(() => PostalCodeUpdateWithoutAddressInput, {nullable:false})
    @Type(() => PostalCodeUpdateWithoutAddressInput)
    data!: InstanceType<typeof PostalCodeUpdateWithoutAddressInput>;
}

@InputType()
export class PostalCodeUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class PostalCodeUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    code?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateManyWithoutPostalCodeNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateManyWithoutPostalCodeNestedInput>;
}

@InputType()
export class PostalCodeUpsertWithoutAddressInput {
    @Field(() => PostalCodeUpdateWithoutAddressInput, {nullable:false})
    @Type(() => PostalCodeUpdateWithoutAddressInput)
    update!: InstanceType<typeof PostalCodeUpdateWithoutAddressInput>;
    @Field(() => PostalCodeCreateWithoutAddressInput, {nullable:false})
    @Type(() => PostalCodeCreateWithoutAddressInput)
    create!: InstanceType<typeof PostalCodeCreateWithoutAddressInput>;
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
}

@InputType()
export class PostalCodeWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    code?: number;
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    AND?: Array<PostalCodeWhereInput>;
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    OR?: Array<PostalCodeWhereInput>;
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    NOT?: Array<PostalCodeWhereInput>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@InputType()
export class PostalCodeWhereInput {
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    AND?: Array<PostalCodeWhereInput>;
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    OR?: Array<PostalCodeWhereInput>;
    @Field(() => [PostalCodeWhereInput], {nullable:true})
    NOT?: Array<PostalCodeWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    code?: InstanceType<typeof IntFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@ObjectType()
export class PostalCode {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    code!: number;
    @Field(() => [Address], {nullable:true})
    address?: Array<Address>;
    @Field(() => PostalCodeCount, {nullable:false})
    _count?: InstanceType<typeof PostalCodeCount>;
}

@ArgsType()
export class UpdateManyPostalCodeArgs {
    @Field(() => PostalCodeUpdateManyMutationInput, {nullable:false})
    @Type(() => PostalCodeUpdateManyMutationInput)
    data!: InstanceType<typeof PostalCodeUpdateManyMutationInput>;
    @Field(() => PostalCodeWhereInput, {nullable:true})
    @Type(() => PostalCodeWhereInput)
    where?: InstanceType<typeof PostalCodeWhereInput>;
}

@ArgsType()
export class UpdateOnePostalCodeArgs {
    @Field(() => PostalCodeUpdateInput, {nullable:false})
    @Type(() => PostalCodeUpdateInput)
    data!: InstanceType<typeof PostalCodeUpdateInput>;
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
}

@ArgsType()
export class UpsertOnePostalCodeArgs {
    @Field(() => PostalCodeWhereUniqueInput, {nullable:false})
    @Type(() => PostalCodeWhereUniqueInput)
    where!: Prisma.AtLeast<PostalCodeWhereUniqueInput, 'id' | 'code'>;
    @Field(() => PostalCodeCreateInput, {nullable:false})
    @Type(() => PostalCodeCreateInput)
    create!: InstanceType<typeof PostalCodeCreateInput>;
    @Field(() => PostalCodeUpdateInput, {nullable:false})
    @Type(() => PostalCodeUpdateInput)
    update!: InstanceType<typeof PostalCodeUpdateInput>;
}

@ObjectType()
export class AffectedRows {
    @Field(() => Int, {nullable:false})
    count!: number;
}

@InputType()
export class BoolFieldUpdateOperationsInput {
    @Field(() => Boolean, {nullable:true})
    set?: boolean;
}

@InputType()
export class BoolFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class BoolWithAggregatesFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _min?: InstanceType<typeof NestedBoolFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _max?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class DateTimeFieldUpdateOperationsInput {
    @Field(() => Date, {nullable:true})
    set?: Date | string;
}

@InputType()
export class DateTimeFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class DateTimeNullableFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class DateTimeNullableWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class DateTimeWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class EnumAccountCategoryFieldUpdateOperationsInput {
    @Field(() => AccountCategory, {nullable:true})
    set?: keyof typeof AccountCategory;
}

@InputType()
export class EnumAccountCategoryFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class EnumAccountCategoryWithAggregatesFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class EnumFileTypeFieldUpdateOperationsInput {
    @Field(() => FileType, {nullable:true})
    set?: keyof typeof FileType;
}

@InputType()
export class EnumFileTypeFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class EnumFileTypeWithAggregatesFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFileTypeFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class EnumPointTypeFieldUpdateOperationsInput {
    @Field(() => PointType, {nullable:true})
    set?: keyof typeof PointType;
}

@InputType()
export class EnumPointTypeFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class EnumPointTypeWithAggregatesFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumPointTypeFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class EnumProjectCategoryFieldUpdateOperationsInput {
    @Field(() => ProjectCategory, {nullable:true})
    set?: keyof typeof ProjectCategory;
}

@InputType()
export class EnumProjectCategoryFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class EnumProjectCategoryWithAggregatesFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class EnumShippingStatusFieldUpdateOperationsInput {
    @Field(() => ShippingStatus, {nullable:true})
    set?: keyof typeof ShippingStatus;
}

@InputType()
export class EnumShippingStatusFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class EnumShippingStatusWithAggregatesFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumShippingStatusFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class EnumThemeFieldUpdateOperationsInput {
    @Field(() => Theme, {nullable:true})
    set?: keyof typeof Theme;
}

@InputType()
export class EnumThemeFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class EnumThemeWithAggregatesFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumThemeFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class EnumTransactionCategoryFieldUpdateOperationsInput {
    @Field(() => TransactionCategory, {nullable:true})
    set?: keyof typeof TransactionCategory;
}

@InputType()
export class EnumTransactionCategoryFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class EnumTransactionCategoryWithAggregatesFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class EnumTransactionStatusFieldUpdateOperationsInput {
    @Field(() => TransactionStatus, {nullable:true})
    set?: keyof typeof TransactionStatus;
}

@InputType()
export class EnumTransactionStatusFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class EnumTransactionStatusWithAggregatesFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class EnumTransactionTypeFieldUpdateOperationsInput {
    @Field(() => TransactionType, {nullable:true})
    set?: keyof typeof TransactionType;
}

@InputType()
export class EnumTransactionTypeFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class EnumTransactionTypeWithAggregatesFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class EnumUserNotificationCategoryFieldUpdateOperationsInput {
    @Field(() => UserNotificationCategory, {nullable:true})
    set?: keyof typeof UserNotificationCategory;
}

@InputType()
export class EnumUserNotificationCategoryFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class EnumUserNotificationCategoryWithAggregatesFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class EnumUserRoleFieldUpdateOperationsInput {
    @Field(() => UserRole, {nullable:true})
    set?: keyof typeof UserRole;
}

@InputType()
export class EnumUserRoleFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class EnumUserRoleWithAggregatesFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserRoleFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class EnumUserStatusFieldUpdateOperationsInput {
    @Field(() => UserStatus, {nullable:true})
    set?: keyof typeof UserStatus;
}

@InputType()
export class EnumUserStatusFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class EnumUserStatusWithAggregatesFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserStatusFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class EnumUserTypeFieldUpdateOperationsInput {
    @Field(() => UserType, {nullable:true})
    set?: keyof typeof UserType;
}

@InputType()
export class EnumUserTypeFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class EnumUserTypeWithAggregatesFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserTypeFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class FloatFieldUpdateOperationsInput {
    @Field(() => Float, {nullable:true})
    set?: number;
    @Field(() => Float, {nullable:true})
    increment?: number;
    @Field(() => Float, {nullable:true})
    decrement?: number;
    @Field(() => Float, {nullable:true})
    multiply?: number;
    @Field(() => Float, {nullable:true})
    divide?: number;
}

@InputType()
export class FloatFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class FloatWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class IntFieldUpdateOperationsInput {
    @Field(() => Int, {nullable:true})
    set?: number;
    @Field(() => Int, {nullable:true})
    increment?: number;
    @Field(() => Int, {nullable:true})
    decrement?: number;
    @Field(() => Int, {nullable:true})
    multiply?: number;
    @Field(() => Int, {nullable:true})
    divide?: number;
}

@InputType()
export class IntFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class IntNullableFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class IntNullableWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class IntWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedBoolFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class NestedBoolWithAggregatesFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _min?: InstanceType<typeof NestedBoolFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _max?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class NestedDateTimeFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class NestedDateTimeNullableFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class NestedDateTimeNullableWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class NestedDateTimeWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class NestedEnumAccountCategoryFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class NestedEnumAccountCategoryWithAggregatesFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class NestedEnumFileTypeFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class NestedEnumFileTypeWithAggregatesFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFileTypeFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class NestedEnumPointTypeFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class NestedEnumPointTypeWithAggregatesFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumPointTypeFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class NestedEnumProjectCategoryFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class NestedEnumProjectCategoryWithAggregatesFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class NestedEnumShippingStatusFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class NestedEnumShippingStatusWithAggregatesFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumShippingStatusFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class NestedEnumThemeFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class NestedEnumThemeWithAggregatesFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumThemeFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class NestedEnumTransactionCategoryFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class NestedEnumTransactionCategoryWithAggregatesFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class NestedEnumTransactionStatusFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class NestedEnumTransactionStatusWithAggregatesFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class NestedEnumTransactionTypeFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class NestedEnumTransactionTypeWithAggregatesFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class NestedEnumUserNotificationCategoryFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class NestedEnumUserNotificationCategoryWithAggregatesFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class NestedEnumUserRoleFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class NestedEnumUserRoleWithAggregatesFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserRoleFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class NestedEnumUserStatusFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class NestedEnumUserStatusWithAggregatesFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserStatusFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class NestedEnumUserTypeFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class NestedEnumUserTypeWithAggregatesFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserTypeFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class NestedFloatFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class NestedFloatNullableFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatNullableFilter>;
}

@InputType()
export class NestedFloatWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class NestedIntFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedIntNullableFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class NestedIntNullableWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class NestedIntWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedStringFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class NestedStringNullableFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class NestedStringNullableWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class NestedStringWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class NullableDateTimeFieldUpdateOperationsInput {
    @Field(() => Date, {nullable:true})
    set?: Date | string;
}

@InputType()
export class NullableIntFieldUpdateOperationsInput {
    @Field(() => Int, {nullable:true})
    set?: number;
    @Field(() => Int, {nullable:true})
    increment?: number;
    @Field(() => Int, {nullable:true})
    decrement?: number;
    @Field(() => Int, {nullable:true})
    multiply?: number;
    @Field(() => Int, {nullable:true})
    divide?: number;
}

@InputType()
export class NullableStringFieldUpdateOperationsInput {
    @Field(() => String, {nullable:true})
    set?: string;
}

@InputType()
export class SortOrderInput {
    @Field(() => SortOrder, {nullable:false})
    sort!: keyof typeof SortOrder;
    @Field(() => NullsOrder, {nullable:true})
    nulls?: keyof typeof NullsOrder;
}

@InputType()
export class StringFieldUpdateOperationsInput {
    @Field(() => String, {nullable:true})
    set?: string;
}

@InputType()
export class StringFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class StringNullableFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class StringNullableWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class StringWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringFilter>;
}

@ObjectType()
export class AggregateProgram {
    @Field(() => ProgramCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregate>;
    @Field(() => ProgramAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregate>;
    @Field(() => ProgramSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregate>;
    @Field(() => ProgramMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregate>;
    @Field(() => ProgramMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregate>;
}

@ArgsType()
export class CreateManyProgramArgs {
    @Field(() => [ProgramCreateManyInput], {nullable:false})
    @Type(() => ProgramCreateManyInput)
    data!: Array<ProgramCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProgramArgs {
    @Field(() => ProgramCreateInput, {nullable:false})
    @Type(() => ProgramCreateInput)
    data!: InstanceType<typeof ProgramCreateInput>;
}

@ArgsType()
export class DeleteManyProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@ArgsType()
export class DeleteOneProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FindFirstProgramOrThrowArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindManyProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProgramOrThrowArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FindUniqueProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class ProgramAggregateArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregateInput>;
    @Field(() => ProgramAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregateInput>;
    @Field(() => ProgramSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregateInput>;
    @Field(() => ProgramMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregateInput>;
    @Field(() => ProgramMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregateInput>;
}

@InputType()
export class ProgramAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
}

@ObjectType()
export class ProgramAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    categoryId?: number;
}

@InputType()
export class ProgramAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProgramCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    dueDate!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProgramCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProgramCount {
    @Field(() => Int, {nullable:false})
    Images?: number;
    @Field(() => Int, {nullable:false})
    participant?: number;
}

@InputType()
export class ProgramCreateManyCategoryInputEnvelope {
    @Field(() => [ProgramCreateManyCategoryInput], {nullable:false})
    @Type(() => ProgramCreateManyCategoryInput)
    data!: Array<ProgramCreateManyCategoryInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ProgramCreateManyCategoryInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateManyCreatedByInputEnvelope {
    @Field(() => [ProgramCreateManyCreatedByInput], {nullable:false})
    @Type(() => ProgramCreateManyCreatedByInput)
    data!: Array<ProgramCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ProgramCreateManyCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateNestedManyWithoutCategoryInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramCreateNestedManyWithoutCreatedByInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramCreateNestedManyWithoutParticipantInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramCreateNestedOneWithoutImagesInput {
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateWithoutImagesInput)
    create?: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProgramCreateOrConnectWithoutImagesInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
}

@InputType()
export class ProgramCreateOrConnectWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramCreateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create!: InstanceType<typeof ProgramCreateWithoutCategoryInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create!: InstanceType<typeof ProgramCreateWithoutCreatedByInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutImagesInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramCreateWithoutImagesInput)
    create!: InstanceType<typeof ProgramCreateWithoutImagesInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramCreateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create!: InstanceType<typeof ProgramCreateWithoutParticipantInput>;
}

@InputType()
export class ProgramCreateWithoutCategoryInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @Field(() => UserCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramCreateWithoutCreatedByInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @Field(() => UserCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateWithoutParticipantInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @Field(() => UserCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@ArgsType()
export class ProgramGroupByArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithAggregationInput>;
    @Field(() => [ProgramScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProgramScalarFieldEnum>;
    @Field(() => ProgramScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProgramScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregateInput>;
    @Field(() => ProgramAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregateInput>;
    @Field(() => ProgramSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregateInput>;
    @Field(() => ProgramMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregateInput>;
    @Field(() => ProgramMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregateInput>;
}

@ObjectType()
export class ProgramGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProgramCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregate>;
    @Field(() => ProgramAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregate>;
    @Field(() => ProgramSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregate>;
    @Field(() => ProgramMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregate>;
    @Field(() => ProgramMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregate>;
}

@InputType()
export class ProgramListRelationFilter {
    @Field(() => ProgramWhereInput, {nullable:true})
    every?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    some?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    none?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramNullableRelationFilter {
    @Field(() => ProgramWhereInput, {nullable:true})
    is?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ProgramOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    dueDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountOrderByAggregateInput>;
    @Field(() => ProgramAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgOrderByAggregateInput>;
    @Field(() => ProgramMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxOrderByAggregateInput>;
    @Field(() => ProgramMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinOrderByAggregateInput>;
    @Field(() => ProgramSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumOrderByAggregateInput>;
}

@InputType()
export class ProgramOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    dueDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    Images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    participant?: InstanceType<typeof UserOrderByRelationAggregateInput>;
    @Field(() => ProgramCategoryOrderByWithRelationInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryOrderByWithRelationInput>;
}

@InputType()
export class ProgramScalarWhereWithAggregatesInput {
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProgramScalarWhereInput {
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    AND?: Array<ProgramScalarWhereInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    OR?: Array<ProgramScalarWhereInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    NOT?: Array<ProgramScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ProgramSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
}

@ObjectType()
export class ProgramSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
}

@InputType()
export class ProgramSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutCategoryInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutParticipantInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class ProgramUncheckedCreateWithoutCategoryInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutParticipantInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
}

@InputType()
export class ProgramUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCategoryNestedInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCategoryInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCategoryInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCategoryInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCategoryInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCategoryInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCategoryInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutParticipantNestedInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutParticipantInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutParticipantInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutParticipantInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutParticipantInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutParticipantInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutCategoryInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutParticipantInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutCategoryInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutParticipantInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithoutCategoryNestedInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCategoryInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCategoryInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCategoryInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCategoryInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCategoryInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateManyWithoutParticipantNestedInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutParticipantInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutParticipantInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutParticipantInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutParticipantInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateOneWithoutImagesNestedInput {
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateWithoutImagesInput)
    create?: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProgramCreateOrConnectWithoutImagesInput>;
    @Field(() => ProgramUpsertWithoutImagesInput, {nullable:true})
    @Type(() => ProgramUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof ProgramUpsertWithoutImagesInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    disconnect?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    delete?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => ProgramUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof ProgramUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class ProgramUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutImagesInput)
    data!: InstanceType<typeof ProgramUpdateWithoutImagesInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCategoryInput)
    data!: InstanceType<typeof ProgramUpdateWithoutCategoryInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof ProgramUpdateWithoutCreatedByInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutParticipantInput)
    data!: InstanceType<typeof ProgramUpdateWithoutParticipantInput>;
}

@InputType()
export class ProgramUpdateWithoutCategoryInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutCreatedByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutParticipantInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCategoryInput)
    update!: InstanceType<typeof ProgramUpdateWithoutCategoryInput>;
    @Field(() => ProgramCreateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create!: InstanceType<typeof ProgramCreateWithoutCategoryInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof ProgramUpdateWithoutCreatedByInput>;
    @Field(() => ProgramCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create!: InstanceType<typeof ProgramCreateWithoutCreatedByInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramUpdateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutParticipantInput)
    update!: InstanceType<typeof ProgramUpdateWithoutParticipantInput>;
    @Field(() => ProgramCreateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create!: InstanceType<typeof ProgramCreateWithoutParticipantInput>;
}

@InputType()
export class ProgramUpsertWithoutImagesInput {
    @Field(() => ProgramUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutImagesInput)
    update!: InstanceType<typeof ProgramUpdateWithoutImagesInput>;
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramCreateWithoutImagesInput)
    create!: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => [ProgramWhereInput], {nullable:true})
    AND?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    OR?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    NOT?: Array<ProgramWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    Images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    participant?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => ProgramCategoryRelationFilter, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryRelationFilter>;
}

@InputType()
export class ProgramWhereInput {
    @Field(() => [ProgramWhereInput], {nullable:true})
    AND?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    OR?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    NOT?: Array<ProgramWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    Images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    participant?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => ProgramCategoryRelationFilter, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryRelationFilter>;
}

@ObjectType()
export class Program {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Date, {nullable:true})
    dueDate!: Date | null;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    Images?: Array<Images>;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
    @Field(() => [User], {nullable:true})
    participant?: Array<User>;
    @Field(() => ProgramCategory, {nullable:false})
    category?: InstanceType<typeof ProgramCategory>;
    @Field(() => ProgramCount, {nullable:false})
    _count?: InstanceType<typeof ProgramCount>;
}

@ArgsType()
export class UpdateManyProgramArgs {
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@ArgsType()
export class UpdateOneProgramArgs {
    @Field(() => ProgramUpdateInput, {nullable:false})
    @Type(() => ProgramUpdateInput)
    data!: InstanceType<typeof ProgramUpdateInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class UpsertOneProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => ProgramCreateInput, {nullable:false})
    @Type(() => ProgramCreateInput)
    create!: InstanceType<typeof ProgramCreateInput>;
    @Field(() => ProgramUpdateInput, {nullable:false})
    @Type(() => ProgramUpdateInput)
    update!: InstanceType<typeof ProgramUpdateInput>;
}

@ObjectType()
export class AggregateProgramCategory {
    @Field(() => ProgramCategoryCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregate>;
    @Field(() => ProgramCategoryAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregate>;
    @Field(() => ProgramCategorySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregate>;
    @Field(() => ProgramCategoryMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregate>;
    @Field(() => ProgramCategoryMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregate>;
}

@ArgsType()
export class CreateManyProgramCategoryArgs {
    @Field(() => [ProgramCategoryCreateManyInput], {nullable:false})
    @Type(() => ProgramCategoryCreateManyInput)
    data!: Array<ProgramCategoryCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProgramCategoryArgs {
    @Field(() => ProgramCategoryCreateInput, {nullable:false})
    @Type(() => ProgramCategoryCreateInput)
    data!: InstanceType<typeof ProgramCategoryCreateInput>;
}

@ArgsType()
export class DeleteManyProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@ArgsType()
export class DeleteOneProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstProgramCategoryOrThrowArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindManyProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProgramCategoryOrThrowArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ProgramCategoryAggregateArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCategoryCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregateInput>;
    @Field(() => ProgramCategoryAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregateInput>;
    @Field(() => ProgramCategorySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregateInput>;
    @Field(() => ProgramCategoryMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregateInput>;
    @Field(() => ProgramCategoryMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregateInput>;
}

@InputType()
export class ProgramCategoryAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProgramCategoryAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class ProgramCategoryAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProgramCategoryCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProgramCategoryCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProgramCategoryCount {
    @Field(() => Int, {nullable:false})
    programs?: number;
}

@InputType()
export class ProgramCategoryCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryCreateNestedOneWithoutProgramsInput {
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create?: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateOrConnectWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateOrConnectWithoutProgramsInput)
    connectOrCreate?: InstanceType<typeof ProgramCategoryCreateOrConnectWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    @Type(() => ProgramCategoryWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@InputType()
export class ProgramCategoryCreateOrConnectWithoutProgramsInput {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create!: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryCreateWithoutProgramsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ProgramCreateNestedManyWithoutCategoryInput, {nullable:true})
    programs?: InstanceType<typeof ProgramCreateNestedManyWithoutCategoryInput>;
}

@ArgsType()
export class ProgramCategoryGroupByArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithAggregationInput>;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
    @Field(() => ProgramCategoryScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCategoryCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregateInput>;
    @Field(() => ProgramCategoryAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregateInput>;
    @Field(() => ProgramCategorySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregateInput>;
    @Field(() => ProgramCategoryMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregateInput>;
    @Field(() => ProgramCategoryMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregateInput>;
}

@ObjectType()
export class ProgramCategoryGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProgramCategoryCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregate>;
    @Field(() => ProgramCategoryAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregate>;
    @Field(() => ProgramCategorySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregate>;
    @Field(() => ProgramCategoryMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregate>;
    @Field(() => ProgramCategoryMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregate>;
}

@InputType()
export class ProgramCategoryMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramCategoryMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramCategoryMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramCategoryCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountOrderByAggregateInput>;
    @Field(() => ProgramCategoryAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgOrderByAggregateInput>;
    @Field(() => ProgramCategoryMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxOrderByAggregateInput>;
    @Field(() => ProgramCategoryMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinOrderByAggregateInput>;
    @Field(() => ProgramCategorySumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumOrderByAggregateInput>;
}

@InputType()
export class ProgramCategoryOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramOrderByRelationAggregateInput, {nullable:true})
    programs?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
}

@InputType()
export class ProgramCategoryRelationFilter {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    is?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@InputType()
export class ProgramCategoryScalarWhereWithAggregatesInput {
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProgramCategorySumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProgramCategorySumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class ProgramCategorySumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryUncheckedCreateWithoutProgramsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCategoryInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCategoryInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateWithoutProgramsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCategoryNestedInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCategoryNestedInput>;
}

@InputType()
export class ProgramCategoryUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput {
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create?: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateOrConnectWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateOrConnectWithoutProgramsInput)
    connectOrCreate?: InstanceType<typeof ProgramCategoryCreateOrConnectWithoutProgramsInput>;
    @Field(() => ProgramCategoryUpsertWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryUpsertWithoutProgramsInput)
    upsert?: InstanceType<typeof ProgramCategoryUpsertWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    @Type(() => ProgramCategoryWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput)
    update?: InstanceType<typeof ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => ProgramCategoryUpdateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateWithoutProgramsInput)
    data!: InstanceType<typeof ProgramCategoryUpdateWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryUpdateWithoutProgramsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUpdateManyWithoutCategoryNestedInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUpdateManyWithoutCategoryNestedInput>;
}

@InputType()
export class ProgramCategoryUpsertWithoutProgramsInput {
    @Field(() => ProgramCategoryUpdateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateWithoutProgramsInput)
    update!: InstanceType<typeof ProgramCategoryUpdateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create!: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@InputType()
export class ProgramCategoryWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    AND?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    OR?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    NOT?: Array<ProgramCategoryWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programs?: InstanceType<typeof ProgramListRelationFilter>;
}

@InputType()
export class ProgramCategoryWhereInput {
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    AND?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    OR?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    NOT?: Array<ProgramCategoryWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programs?: InstanceType<typeof ProgramListRelationFilter>;
}

@ObjectType()
export class ProgramCategory {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Program], {nullable:true})
    programs?: Array<Program>;
    @Field(() => ProgramCategoryCount, {nullable:false})
    _count?: InstanceType<typeof ProgramCategoryCount>;
}

@ArgsType()
export class UpdateManyProgramCategoryArgs {
    @Field(() => ProgramCategoryUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramCategoryUpdateManyMutationInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@ArgsType()
export class UpdateOneProgramCategoryArgs {
    @Field(() => ProgramCategoryUpdateInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateInput)
    data!: InstanceType<typeof ProgramCategoryUpdateInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryCreateInput, {nullable:false})
    @Type(() => ProgramCategoryCreateInput)
    create!: InstanceType<typeof ProgramCategoryCreateInput>;
    @Field(() => ProgramCategoryUpdateInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateInput)
    update!: InstanceType<typeof ProgramCategoryUpdateInput>;
}

@ObjectType()
export class AggregateProject {
    @Field(() => ProjectCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregate>;
    @Field(() => ProjectAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregate>;
    @Field(() => ProjectSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregate>;
    @Field(() => ProjectMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregate>;
    @Field(() => ProjectMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregate>;
}

@ArgsType()
export class CreateManyProjectArgs {
    @Field(() => [ProjectCreateManyInput], {nullable:false})
    @Type(() => ProjectCreateManyInput)
    data!: Array<ProjectCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProjectArgs {
    @Field(() => ProjectCreateInput, {nullable:false})
    @Type(() => ProjectCreateInput)
    data!: InstanceType<typeof ProjectCreateInput>;
}

@ArgsType()
export class DeleteManyProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@ArgsType()
export class DeleteOneProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindFirstProjectOrThrowArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindManyProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProjectOrThrowArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindUniqueProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class ProjectAggregateArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProjectCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregateInput>;
    @Field(() => ProjectAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregateInput>;
    @Field(() => ProjectSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregateInput>;
    @Field(() => ProjectMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregateInput>;
    @Field(() => ProjectMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregateInput>;
}

@InputType()
export class ProjectAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    currentAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class ProjectAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Float, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    currentAmount?: number;
    @Field(() => Float, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Float, {nullable:true})
    maxInvestor?: number;
    @Field(() => Float, {nullable:true})
    accountId?: number;
}

@InputType()
export class ProjectAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class ProjectCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    currentAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProjectCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    projectCategory!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    endDate!: number;
    @Field(() => Int, {nullable:false})
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    goalAmount!: number;
    @Field(() => Int, {nullable:false})
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProjectCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProjectCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    investors?: number;
}

@InputType()
export class ProjectCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProjectCreateNestedManyWithoutInvestorsInput {
    @Field(() => [ProjectCreateWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create?: Array<ProjectCreateWithoutInvestorsInput>;
    @Field(() => [ProjectCreateOrConnectWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutInvestorsInput)
    connectOrCreate?: Array<ProjectCreateOrConnectWithoutInvestorsInput>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
}

@InputType()
export class ProjectCreateNestedOneWithoutAccountInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectCreateNestedOneWithoutImagesInput {
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateWithoutImagesInput)
    create?: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutImagesInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectCreateOrConnectWithoutAccountInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectCreateWithoutAccountInput)
    create!: InstanceType<typeof ProjectCreateWithoutAccountInput>;
}

@InputType()
export class ProjectCreateOrConnectWithoutImagesInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectCreateWithoutImagesInput)
    create!: InstanceType<typeof ProjectCreateWithoutImagesInput>;
}

@InputType()
export class ProjectCreateOrConnectWithoutInvestorsInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutInvestorsInput, {nullable:false})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create!: InstanceType<typeof ProjectCreateWithoutInvestorsInput>;
}

@InputType()
export class ProjectCreateWithoutAccountInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @Field(() => UserCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserCreateNestedManyWithoutProjectsInvestmentInput>;
}

@InputType()
export class ProjectCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserCreateNestedManyWithoutProjectsInvestmentInput>;
    @Field(() => AccountCreateNestedOneWithoutProjectInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@InputType()
export class ProjectCreateWithoutInvestorsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @Field(() => AccountCreateNestedOneWithoutProjectInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@InputType()
export class ProjectCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @Field(() => UserCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserCreateNestedManyWithoutProjectsInvestmentInput>;
    @Field(() => AccountCreateNestedOneWithoutProjectInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@ArgsType()
export class ProjectGroupByArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithAggregationInput>;
    @Field(() => [ProjectScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProjectScalarFieldEnum>;
    @Field(() => ProjectScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProjectScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProjectCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregateInput>;
    @Field(() => ProjectAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregateInput>;
    @Field(() => ProjectSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregateInput>;
    @Field(() => ProjectMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregateInput>;
    @Field(() => ProjectMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregateInput>;
}

@ObjectType()
export class ProjectGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProjectCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregate>;
    @Field(() => ProjectAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregate>;
    @Field(() => ProjectSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregate>;
    @Field(() => ProjectMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregate>;
    @Field(() => ProjectMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregate>;
}

@InputType()
export class ProjectListRelationFilter {
    @Field(() => ProjectWhereInput, {nullable:true})
    every?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    some?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    none?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    currentAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProjectMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => ProjectCategory, {nullable:true})
    projectCategory?: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    endDate?: Date | string;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Int, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    currentAmount?: number;
    @Field(() => Int, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProjectMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProjectMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    currentAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProjectMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => ProjectCategory, {nullable:true})
    projectCategory?: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    endDate?: Date | string;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Int, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    currentAmount?: number;
    @Field(() => Int, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProjectMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProjectNullableRelationFilter {
    @Field(() => ProjectWhereInput, {nullable:true})
    is?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ProjectOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProjectCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountOrderByAggregateInput>;
    @Field(() => ProjectAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgOrderByAggregateInput>;
    @Field(() => ProjectMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxOrderByAggregateInput>;
    @Field(() => ProjectMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinOrderByAggregateInput>;
    @Field(() => ProjectSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumOrderByAggregateInput>;
}

@InputType()
export class ProjectOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    investors?: InstanceType<typeof UserOrderByRelationAggregateInput>;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    account?: InstanceType<typeof AccountOrderByWithRelationInput>;
}

@InputType()
export class ProjectScalarWhereWithAggregatesInput {
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => EnumProjectCategoryWithAggregatesFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    goalAmount?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    currentAmount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    accountId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProjectScalarWhereInput {
    @Field(() => [ProjectScalarWhereInput], {nullable:true})
    AND?: Array<ProjectScalarWhereInput>;
    @Field(() => [ProjectScalarWhereInput], {nullable:true})
    OR?: Array<ProjectScalarWhereInput>;
    @Field(() => [ProjectScalarWhereInput], {nullable:true})
    NOT?: Array<ProjectScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => EnumProjectCategoryFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    goalAmount?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ProjectSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    currentAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class ProjectSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Int, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    currentAmount?: number;
    @Field(() => Int, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class ProjectSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class ProjectUncheckedCreateNestedManyWithoutInvestorsInput {
    @Field(() => [ProjectCreateWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create?: Array<ProjectCreateWithoutInvestorsInput>;
    @Field(() => [ProjectCreateOrConnectWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutInvestorsInput)
    connectOrCreate?: Array<ProjectCreateOrConnectWithoutInvestorsInput>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
}

@InputType()
export class ProjectUncheckedCreateNestedOneWithoutAccountInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectUncheckedCreateWithoutAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput>;
}

@InputType()
export class ProjectUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput>;
}

@InputType()
export class ProjectUncheckedCreateWithoutInvestorsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
}

@InputType()
export class ProjectUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput>;
}

@InputType()
export class ProjectUncheckedUpdateManyWithoutInvestorsNestedInput {
    @Field(() => [ProjectCreateWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create?: Array<ProjectCreateWithoutInvestorsInput>;
    @Field(() => [ProjectCreateOrConnectWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutInvestorsInput)
    connectOrCreate?: Array<ProjectCreateOrConnectWithoutInvestorsInput>;
    @Field(() => [ProjectUpsertWithWhereUniqueWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpsertWithWhereUniqueWithoutInvestorsInput)
    upsert?: Array<ProjectUpsertWithWhereUniqueWithoutInvestorsInput>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectUpdateWithWhereUniqueWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpdateWithWhereUniqueWithoutInvestorsInput)
    update?: Array<ProjectUpdateWithWhereUniqueWithoutInvestorsInput>;
    @Field(() => [ProjectUpdateManyWithWhereWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpdateManyWithWhereWithoutInvestorsInput)
    updateMany?: Array<ProjectUpdateManyWithWhereWithoutInvestorsInput>;
    @Field(() => [ProjectScalarWhereInput], {nullable:true})
    @Type(() => ProjectScalarWhereInput)
    deleteMany?: Array<ProjectScalarWhereInput>;
}

@InputType()
export class ProjectUncheckedUpdateManyWithoutInvestorsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProjectUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProjectUncheckedUpdateOneWithoutAccountNestedInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectUpsertWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutInvestorsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput>;
}

@InputType()
export class ProjectUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProjectUpdateManyWithWhereWithoutInvestorsInput {
    @Field(() => ProjectScalarWhereInput, {nullable:false})
    @Type(() => ProjectScalarWhereInput)
    where!: InstanceType<typeof ProjectScalarWhereInput>;
    @Field(() => ProjectUpdateManyMutationInput, {nullable:false})
    @Type(() => ProjectUpdateManyMutationInput)
    data!: InstanceType<typeof ProjectUpdateManyMutationInput>;
}

@InputType()
export class ProjectUpdateManyWithoutInvestorsNestedInput {
    @Field(() => [ProjectCreateWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create?: Array<ProjectCreateWithoutInvestorsInput>;
    @Field(() => [ProjectCreateOrConnectWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutInvestorsInput)
    connectOrCreate?: Array<ProjectCreateOrConnectWithoutInvestorsInput>;
    @Field(() => [ProjectUpsertWithWhereUniqueWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpsertWithWhereUniqueWithoutInvestorsInput)
    upsert?: Array<ProjectUpsertWithWhereUniqueWithoutInvestorsInput>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectWhereUniqueInput], {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>>;
    @Field(() => [ProjectUpdateWithWhereUniqueWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpdateWithWhereUniqueWithoutInvestorsInput)
    update?: Array<ProjectUpdateWithWhereUniqueWithoutInvestorsInput>;
    @Field(() => [ProjectUpdateManyWithWhereWithoutInvestorsInput], {nullable:true})
    @Type(() => ProjectUpdateManyWithWhereWithoutInvestorsInput)
    updateMany?: Array<ProjectUpdateManyWithWhereWithoutInvestorsInput>;
    @Field(() => [ProjectScalarWhereInput], {nullable:true})
    @Type(() => ProjectScalarWhereInput)
    deleteMany?: Array<ProjectScalarWhereInput>;
}

@InputType()
export class ProjectUpdateOneWithoutAccountNestedInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectUpsertWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class ProjectUpdateOneWithoutImagesNestedInput {
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateWithoutImagesInput)
    create?: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutImagesInput>;
    @Field(() => ProjectUpsertWithoutImagesInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutImagesInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class ProjectUpdateToOneWithWhereWithoutAccountInput {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectUpdateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutAccountInput)
    data!: InstanceType<typeof ProjectUpdateWithoutAccountInput>;
}

@InputType()
export class ProjectUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutImagesInput)
    data!: InstanceType<typeof ProjectUpdateWithoutImagesInput>;
}

@InputType()
export class ProjectUpdateWithWhereUniqueWithoutInvestorsInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateWithoutInvestorsInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutInvestorsInput)
    data!: InstanceType<typeof ProjectUpdateWithoutInvestorsInput>;
}

@InputType()
export class ProjectUpdateWithoutAccountInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => UserUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUpdateManyWithoutProjectsInvestmentNestedInput>;
}

@InputType()
export class ProjectUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUpdateManyWithoutProjectsInvestmentNestedInput>;
    @Field(() => AccountUpdateOneRequiredWithoutProjectNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpdateWithoutInvestorsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => AccountUpdateOneRequiredWithoutProjectNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => UserUpdateManyWithoutProjectsInvestmentNestedInput, {nullable:true})
    investors?: InstanceType<typeof UserUpdateManyWithoutProjectsInvestmentNestedInput>;
    @Field(() => AccountUpdateOneRequiredWithoutProjectNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpsertWithWhereUniqueWithoutInvestorsInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateWithoutInvestorsInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutInvestorsInput)
    update!: InstanceType<typeof ProjectUpdateWithoutInvestorsInput>;
    @Field(() => ProjectCreateWithoutInvestorsInput, {nullable:false})
    @Type(() => ProjectCreateWithoutInvestorsInput)
    create!: InstanceType<typeof ProjectCreateWithoutInvestorsInput>;
}

@InputType()
export class ProjectUpsertWithoutAccountInput {
    @Field(() => ProjectUpdateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutAccountInput)
    update!: InstanceType<typeof ProjectUpdateWithoutAccountInput>;
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectCreateWithoutAccountInput)
    create!: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectUpsertWithoutImagesInput {
    @Field(() => ProjectUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutImagesInput)
    update!: InstanceType<typeof ProjectUpdateWithoutImagesInput>;
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectCreateWithoutImagesInput)
    create!: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => [ProjectWhereInput], {nullable:true})
    AND?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    OR?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    NOT?: Array<ProjectWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => EnumProjectCategoryFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    goalAmount?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    investors?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@InputType()
export class ProjectWhereInput {
    @Field(() => [ProjectWhereInput], {nullable:true})
    AND?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    OR?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    NOT?: Array<ProjectWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => EnumProjectCategoryFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    goalAmount?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentAmount?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    investors?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@ObjectType()
export class Project {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Date, {nullable:false})
    endDate!: Date;
    @Field(() => Float, {nullable:false})
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    currentAmount!: number;
    @Field(() => Int, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [User], {nullable:true})
    investors?: Array<User>;
    @Field(() => Account, {nullable:false})
    account?: InstanceType<typeof Account>;
    @Field(() => ProjectCount, {nullable:false})
    _count?: InstanceType<typeof ProjectCount>;
}

@ArgsType()
export class UpdateManyProjectArgs {
    @Field(() => ProjectUpdateManyMutationInput, {nullable:false})
    @Type(() => ProjectUpdateManyMutationInput)
    data!: InstanceType<typeof ProjectUpdateManyMutationInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@ArgsType()
export class UpdateOneProjectArgs {
    @Field(() => ProjectUpdateInput, {nullable:false})
    @Type(() => ProjectUpdateInput)
    data!: InstanceType<typeof ProjectUpdateInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpsertOneProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateInput, {nullable:false})
    @Type(() => ProjectCreateInput)
    create!: InstanceType<typeof ProjectCreateInput>;
    @Field(() => ProjectUpdateInput, {nullable:false})
    @Type(() => ProjectUpdateInput)
    update!: InstanceType<typeof ProjectUpdateInput>;
}

@ObjectType()
export class AggregateReward {
    @Field(() => RewardCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregate>;
    @Field(() => RewardAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregate>;
    @Field(() => RewardSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregate>;
    @Field(() => RewardMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregate>;
    @Field(() => RewardMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregate>;
}

@ArgsType()
export class CreateManyRewardArgs {
    @Field(() => [RewardCreateManyInput], {nullable:false})
    @Type(() => RewardCreateManyInput)
    data!: Array<RewardCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneRewardArgs {
    @Field(() => RewardCreateInput, {nullable:false})
    @Type(() => RewardCreateInput)
    data!: InstanceType<typeof RewardCreateInput>;
}

@ArgsType()
export class DeleteManyRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@ArgsType()
export class DeleteOneRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstRewardOrThrowArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindFirstRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindManyRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueRewardOrThrowArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class RewardAggregateArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregateInput>;
    @Field(() => RewardAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregateInput>;
    @Field(() => RewardSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregateInput>;
    @Field(() => RewardMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregateInput>;
    @Field(() => RewardMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregateInput>;
}

@InputType()
export class RewardAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
}

@ObjectType()
export class RewardAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
}

@InputType()
export class RewardAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
}

@InputType()
export class RewardCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class RewardCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    pointCost!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class RewardCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class RewardCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    claimers?: number;
}

@InputType()
export class RewardCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class RewardCreateNestedManyWithoutClaimersInput {
    @Field(() => [RewardCreateWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateWithoutClaimersInput)
    create?: Array<RewardCreateWithoutClaimersInput>;
    @Field(() => [RewardCreateOrConnectWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutClaimersInput)
    connectOrCreate?: Array<RewardCreateOrConnectWithoutClaimersInput>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardCreateNestedOneWithoutImagesInput {
    @Field(() => RewardCreateWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateWithoutImagesInput)
    create?: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutImagesInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@InputType()
export class RewardCreateOrConnectWithoutClaimersInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateWithoutClaimersInput, {nullable:false})
    @Type(() => RewardCreateWithoutClaimersInput)
    create!: InstanceType<typeof RewardCreateWithoutClaimersInput>;
}

@InputType()
export class RewardCreateOrConnectWithoutImagesInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateWithoutImagesInput, {nullable:false})
    @Type(() => RewardCreateWithoutImagesInput)
    create!: InstanceType<typeof RewardCreateWithoutImagesInput>;
}

@InputType()
export class RewardCreateWithoutClaimersInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutRewardImageInput>;
}

@InputType()
export class RewardCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedManyWithoutClaimedRewardsInput, {nullable:true})
    claimers?: InstanceType<typeof UserCreateNestedManyWithoutClaimedRewardsInput>;
}

@InputType()
export class RewardCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutRewardImageInput>;
    @Field(() => UserCreateNestedManyWithoutClaimedRewardsInput, {nullable:true})
    claimers?: InstanceType<typeof UserCreateNestedManyWithoutClaimedRewardsInput>;
}

@ArgsType()
export class RewardGroupByArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithAggregationInput>;
    @Field(() => [RewardScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof RewardScalarFieldEnum>;
    @Field(() => RewardScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof RewardScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregateInput>;
    @Field(() => RewardAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregateInput>;
    @Field(() => RewardSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregateInput>;
    @Field(() => RewardMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregateInput>;
    @Field(() => RewardMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregateInput>;
}

@ObjectType()
export class RewardGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false})
    pointCost!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => RewardCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregate>;
    @Field(() => RewardAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregate>;
    @Field(() => RewardSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregate>;
    @Field(() => RewardMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregate>;
    @Field(() => RewardMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregate>;
}

@InputType()
export class RewardListRelationFilter {
    @Field(() => RewardWhereInput, {nullable:true})
    every?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    some?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    none?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class RewardMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class RewardMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class RewardMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class RewardMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardNullableRelationFilter {
    @Field(() => RewardWhereInput, {nullable:true})
    is?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    isNot?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class RewardOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => RewardCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountOrderByAggregateInput>;
    @Field(() => RewardAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgOrderByAggregateInput>;
    @Field(() => RewardMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxOrderByAggregateInput>;
    @Field(() => RewardMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinOrderByAggregateInput>;
    @Field(() => RewardSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumOrderByAggregateInput>;
}

@InputType()
export class RewardOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    claimers?: InstanceType<typeof UserOrderByRelationAggregateInput>;
}

@InputType()
export class RewardScalarWhereWithAggregatesInput {
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class RewardScalarWhereInput {
    @Field(() => [RewardScalarWhereInput], {nullable:true})
    AND?: Array<RewardScalarWhereInput>;
    @Field(() => [RewardScalarWhereInput], {nullable:true})
    OR?: Array<RewardScalarWhereInput>;
    @Field(() => [RewardScalarWhereInput], {nullable:true})
    NOT?: Array<RewardScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class RewardSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
}

@ObjectType()
export class RewardSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
}

@InputType()
export class RewardSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
}

@InputType()
export class RewardUncheckedCreateNestedManyWithoutClaimersInput {
    @Field(() => [RewardCreateWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateWithoutClaimersInput)
    create?: Array<RewardCreateWithoutClaimersInput>;
    @Field(() => [RewardCreateOrConnectWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutClaimersInput)
    connectOrCreate?: Array<RewardCreateOrConnectWithoutClaimersInput>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardUncheckedCreateWithoutClaimersInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutRewardImageInput>;
}

@InputType()
export class RewardUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutClaimedRewardsInput, {nullable:true})
    claimers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutClaimedRewardsInput>;
}

@InputType()
export class RewardUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutRewardImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutClaimedRewardsInput, {nullable:true})
    claimers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutClaimedRewardsInput>;
}

@InputType()
export class RewardUncheckedUpdateManyWithoutClaimersNestedInput {
    @Field(() => [RewardCreateWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateWithoutClaimersInput)
    create?: Array<RewardCreateWithoutClaimersInput>;
    @Field(() => [RewardCreateOrConnectWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutClaimersInput)
    connectOrCreate?: Array<RewardCreateOrConnectWithoutClaimersInput>;
    @Field(() => [RewardUpsertWithWhereUniqueWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpsertWithWhereUniqueWithoutClaimersInput)
    upsert?: Array<RewardUpsertWithWhereUniqueWithoutClaimersInput>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardUpdateWithWhereUniqueWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpdateWithWhereUniqueWithoutClaimersInput)
    update?: Array<RewardUpdateWithWhereUniqueWithoutClaimersInput>;
    @Field(() => [RewardUpdateManyWithWhereWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpdateManyWithWhereWithoutClaimersInput)
    updateMany?: Array<RewardUpdateManyWithWhereWithoutClaimersInput>;
    @Field(() => [RewardScalarWhereInput], {nullable:true})
    @Type(() => RewardScalarWhereInput)
    deleteMany?: Array<RewardScalarWhereInput>;
}

@InputType()
export class RewardUncheckedUpdateManyWithoutClaimersInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardUncheckedUpdateWithoutClaimersInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutRewardImageNestedInput>;
}

@InputType()
export class RewardUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutClaimedRewardsNestedInput, {nullable:true})
    claimers?: InstanceType<typeof UserUncheckedUpdateManyWithoutClaimedRewardsNestedInput>;
}

@InputType()
export class RewardUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutRewardImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutClaimedRewardsNestedInput, {nullable:true})
    claimers?: InstanceType<typeof UserUncheckedUpdateManyWithoutClaimedRewardsNestedInput>;
}

@InputType()
export class RewardUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardUpdateManyWithWhereWithoutClaimersInput {
    @Field(() => RewardScalarWhereInput, {nullable:false})
    @Type(() => RewardScalarWhereInput)
    where!: InstanceType<typeof RewardScalarWhereInput>;
    @Field(() => RewardUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardUpdateManyMutationInput)
    data!: InstanceType<typeof RewardUpdateManyMutationInput>;
}

@InputType()
export class RewardUpdateManyWithoutClaimersNestedInput {
    @Field(() => [RewardCreateWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateWithoutClaimersInput)
    create?: Array<RewardCreateWithoutClaimersInput>;
    @Field(() => [RewardCreateOrConnectWithoutClaimersInput], {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutClaimersInput)
    connectOrCreate?: Array<RewardCreateOrConnectWithoutClaimersInput>;
    @Field(() => [RewardUpsertWithWhereUniqueWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpsertWithWhereUniqueWithoutClaimersInput)
    upsert?: Array<RewardUpsertWithWhereUniqueWithoutClaimersInput>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardWhereUniqueInput], {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardWhereUniqueInput, 'id'>>;
    @Field(() => [RewardUpdateWithWhereUniqueWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpdateWithWhereUniqueWithoutClaimersInput)
    update?: Array<RewardUpdateWithWhereUniqueWithoutClaimersInput>;
    @Field(() => [RewardUpdateManyWithWhereWithoutClaimersInput], {nullable:true})
    @Type(() => RewardUpdateManyWithWhereWithoutClaimersInput)
    updateMany?: Array<RewardUpdateManyWithWhereWithoutClaimersInput>;
    @Field(() => [RewardScalarWhereInput], {nullable:true})
    @Type(() => RewardScalarWhereInput)
    deleteMany?: Array<RewardScalarWhereInput>;
}

@InputType()
export class RewardUpdateOneWithoutImagesNestedInput {
    @Field(() => RewardCreateWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateWithoutImagesInput)
    create?: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutImagesInput>;
    @Field(() => RewardUpsertWithoutImagesInput, {nullable:true})
    @Type(() => RewardUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof RewardUpsertWithoutImagesInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    disconnect?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    delete?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => RewardUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof RewardUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class RewardUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardUpdateWithoutImagesInput, {nullable:false})
    @Type(() => RewardUpdateWithoutImagesInput)
    data!: InstanceType<typeof RewardUpdateWithoutImagesInput>;
}

@InputType()
export class RewardUpdateWithWhereUniqueWithoutClaimersInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardUpdateWithoutClaimersInput, {nullable:false})
    @Type(() => RewardUpdateWithoutClaimersInput)
    data!: InstanceType<typeof RewardUpdateWithoutClaimersInput>;
}

@InputType()
export class RewardUpdateWithoutClaimersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutRewardImageNestedInput>;
}

@InputType()
export class RewardUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateManyWithoutClaimedRewardsNestedInput, {nullable:true})
    claimers?: InstanceType<typeof UserUpdateManyWithoutClaimedRewardsNestedInput>;
}

@InputType()
export class RewardUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutRewardImageNestedInput>;
    @Field(() => UserUpdateManyWithoutClaimedRewardsNestedInput, {nullable:true})
    claimers?: InstanceType<typeof UserUpdateManyWithoutClaimedRewardsNestedInput>;
}

@InputType()
export class RewardUpsertWithWhereUniqueWithoutClaimersInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardUpdateWithoutClaimersInput, {nullable:false})
    @Type(() => RewardUpdateWithoutClaimersInput)
    update!: InstanceType<typeof RewardUpdateWithoutClaimersInput>;
    @Field(() => RewardCreateWithoutClaimersInput, {nullable:false})
    @Type(() => RewardCreateWithoutClaimersInput)
    create!: InstanceType<typeof RewardCreateWithoutClaimersInput>;
}

@InputType()
export class RewardUpsertWithoutImagesInput {
    @Field(() => RewardUpdateWithoutImagesInput, {nullable:false})
    @Type(() => RewardUpdateWithoutImagesInput)
    update!: InstanceType<typeof RewardUpdateWithoutImagesInput>;
    @Field(() => RewardCreateWithoutImagesInput, {nullable:false})
    @Type(() => RewardCreateWithoutImagesInput)
    create!: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [RewardWhereInput], {nullable:true})
    AND?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    OR?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    NOT?: Array<RewardWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    claimers?: InstanceType<typeof UserListRelationFilter>;
}

@InputType()
export class RewardWhereInput {
    @Field(() => [RewardWhereInput], {nullable:true})
    AND?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    OR?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    NOT?: Array<RewardWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    claimers?: InstanceType<typeof UserListRelationFilter>;
}

@ObjectType()
export class Reward {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false})
    pointCost!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [User], {nullable:true})
    claimers?: Array<User>;
    @Field(() => RewardCount, {nullable:false})
    _count?: InstanceType<typeof RewardCount>;
}

@ArgsType()
export class UpdateManyRewardArgs {
    @Field(() => RewardUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardUpdateManyMutationInput)
    data!: InstanceType<typeof RewardUpdateManyMutationInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@ArgsType()
export class UpdateOneRewardArgs {
    @Field(() => RewardUpdateInput, {nullable:false})
    @Type(() => RewardUpdateInput)
    data!: InstanceType<typeof RewardUpdateInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateInput, {nullable:false})
    @Type(() => RewardCreateInput)
    create!: InstanceType<typeof RewardCreateInput>;
    @Field(() => RewardUpdateInput, {nullable:false})
    @Type(() => RewardUpdateInput)
    update!: InstanceType<typeof RewardUpdateInput>;
}

@ObjectType()
export class AggregateSchool {
    @Field(() => SchoolCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregate>;
    @Field(() => SchoolAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregate>;
    @Field(() => SchoolSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregate>;
    @Field(() => SchoolMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregate>;
    @Field(() => SchoolMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregate>;
}

@ArgsType()
export class CreateManySchoolArgs {
    @Field(() => [SchoolCreateManyInput], {nullable:false})
    @Type(() => SchoolCreateManyInput)
    data!: Array<SchoolCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneSchoolArgs {
    @Field(() => SchoolCreateInput, {nullable:false})
    @Type(() => SchoolCreateInput)
    data!: InstanceType<typeof SchoolCreateInput>;
}

@ArgsType()
export class DeleteManySchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@ArgsType()
export class DeleteOneSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindFirstSchoolOrThrowArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindFirstSchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindManySchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueSchoolOrThrowArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindUniqueSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class SchoolAggregateArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SchoolCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregateInput>;
    @Field(() => SchoolAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregateInput>;
    @Field(() => SchoolSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregateInput>;
    @Field(() => SchoolMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregateInput>;
    @Field(() => SchoolMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregateInput>;
}

@InputType()
export class SchoolAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
}

@ObjectType()
export class SchoolAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
}

@InputType()
export class SchoolAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
}

@InputType()
export class SchoolCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class SchoolCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class SchoolCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class SchoolCount {
    @Field(() => Int, {nullable:false})
    students?: number;
}

@InputType()
export class SchoolCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolCreateNestedOneWithoutAddressInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolCreateNestedOneWithoutStudentsInput {
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create?: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolCreateOrConnectWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutStudentsInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutStudentsInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolCreateOrConnectWithoutAddressInput {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolCreateWithoutAddressInput)
    create!: InstanceType<typeof SchoolCreateWithoutAddressInput>;
}

@InputType()
export class SchoolCreateOrConnectWithoutStudentsInput {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create!: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
}

@InputType()
export class SchoolCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolCreateWithoutStudentsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutSchoolInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutSchoolInput>;
}

@InputType()
export class SchoolCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutSchoolInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutSchoolInput>;
    @Field(() => UserCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserCreateNestedManyWithoutSchoolInput>;
}

@ArgsType()
export class SchoolGroupByArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithAggregationInput>;
    @Field(() => [SchoolScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof SchoolScalarFieldEnum>;
    @Field(() => SchoolScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof SchoolScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SchoolCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregateInput>;
    @Field(() => SchoolAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregateInput>;
    @Field(() => SchoolSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregateInput>;
    @Field(() => SchoolMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregateInput>;
    @Field(() => SchoolMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregateInput>;
}

@ObjectType()
export class SchoolGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => SchoolCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregate>;
    @Field(() => SchoolAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregate>;
    @Field(() => SchoolSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregate>;
    @Field(() => SchoolMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregate>;
    @Field(() => SchoolMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregate>;
}

@InputType()
export class SchoolMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class SchoolMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class SchoolMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class SchoolMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class SchoolNullableRelationFilter {
    @Field(() => SchoolWhereInput, {nullable:true})
    is?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    isNot?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SchoolCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountOrderByAggregateInput>;
    @Field(() => SchoolAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgOrderByAggregateInput>;
    @Field(() => SchoolMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxOrderByAggregateInput>;
    @Field(() => SchoolMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinOrderByAggregateInput>;
    @Field(() => SchoolSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumOrderByAggregateInput>;
}

@InputType()
export class SchoolOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    students?: InstanceType<typeof UserOrderByRelationAggregateInput>;
}

@InputType()
export class SchoolScalarWhereWithAggregatesInput {
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class SchoolSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
}

@ObjectType()
export class SchoolSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
}

@InputType()
export class SchoolSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
}

@InputType()
export class SchoolUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolUncheckedCreateWithoutStudentsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolUpsertWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class SchoolUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUncheckedUpdateWithoutStudentsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUpdateOneWithoutAddressNestedInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolUpsertWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class SchoolUpdateOneWithoutStudentsNestedInput {
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create?: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolCreateOrConnectWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutStudentsInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutStudentsInput>;
    @Field(() => SchoolUpsertWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutStudentsInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutStudentsInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutStudentsInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutStudentsInput>;
}

@InputType()
export class SchoolUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutAddressInput)
    data!: InstanceType<typeof SchoolUpdateWithoutAddressInput>;
}

@InputType()
export class SchoolUpdateToOneWithWhereWithoutStudentsInput {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolUpdateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutStudentsInput)
    data!: InstanceType<typeof SchoolUpdateWithoutStudentsInput>;
}

@InputType()
export class SchoolUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateWithoutStudentsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutSchoolNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutSchoolNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutSchoolNestedInput>;
    @Field(() => UserUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpsertWithoutAddressInput {
    @Field(() => SchoolUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutAddressInput)
    update!: InstanceType<typeof SchoolUpdateWithoutAddressInput>;
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolCreateWithoutAddressInput)
    create!: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolUpsertWithoutStudentsInput {
    @Field(() => SchoolUpdateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutStudentsInput)
    update!: InstanceType<typeof SchoolUpdateWithoutStudentsInput>;
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create!: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => [SchoolWhereInput], {nullable:true})
    AND?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    OR?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    NOT?: Array<SchoolWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    students?: InstanceType<typeof UserListRelationFilter>;
}

@InputType()
export class SchoolWhereInput {
    @Field(() => [SchoolWhereInput], {nullable:true})
    AND?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    OR?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    NOT?: Array<SchoolWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    students?: InstanceType<typeof UserListRelationFilter>;
}

@ObjectType()
export class School {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => [User], {nullable:true})
    students?: Array<User>;
    @Field(() => SchoolCount, {nullable:false})
    _count?: InstanceType<typeof SchoolCount>;
}

@ArgsType()
export class UpdateManySchoolArgs {
    @Field(() => SchoolUpdateManyMutationInput, {nullable:false})
    @Type(() => SchoolUpdateManyMutationInput)
    data!: InstanceType<typeof SchoolUpdateManyMutationInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@ArgsType()
export class UpdateOneSchoolArgs {
    @Field(() => SchoolUpdateInput, {nullable:false})
    @Type(() => SchoolUpdateInput)
    data!: InstanceType<typeof SchoolUpdateInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class UpsertOneSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateInput, {nullable:false})
    @Type(() => SchoolCreateInput)
    create!: InstanceType<typeof SchoolCreateInput>;
    @Field(() => SchoolUpdateInput, {nullable:false})
    @Type(() => SchoolUpdateInput)
    update!: InstanceType<typeof SchoolUpdateInput>;
}

@ObjectType()
export class AggregateSession {
    @Field(() => SessionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregate>;
    @Field(() => SessionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregate>;
    @Field(() => SessionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregate>;
    @Field(() => SessionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregate>;
    @Field(() => SessionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregate>;
}

@ArgsType()
export class CreateManySessionArgs {
    @Field(() => [SessionCreateManyInput], {nullable:false})
    @Type(() => SessionCreateManyInput)
    data!: Array<SessionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneSessionArgs {
    @Field(() => SessionCreateInput, {nullable:false})
    @Type(() => SessionCreateInput)
    data!: InstanceType<typeof SessionCreateInput>;
}

@ArgsType()
export class DeleteManySessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
}

@ArgsType()
export class DeleteOneSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class FindFirstSessionOrThrowArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstSessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindManySessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueSessionOrThrowArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class FindUniqueSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class SessionAggregateArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SessionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregateInput>;
    @Field(() => SessionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregateInput>;
    @Field(() => SessionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregateInput>;
    @Field(() => SessionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregateInput>;
    @Field(() => SessionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregateInput>;
}

@InputType()
export class SessionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class SessionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    token!: number;
    @Field(() => Int, {nullable:false})
    expiresAt!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    device!: number;
    @Field(() => Int, {nullable:false})
    ipAddress!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class SessionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionCreateManyUserInputEnvelope {
    @Field(() => [SessionCreateManyUserInput], {nullable:false})
    @Type(() => SessionCreateManyUserInput)
    data!: Array<SessionCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class SessionCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateNestedManyWithoutUserInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
}

@InputType()
export class SessionCreateOrConnectWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionCreateWithoutUserInput, {nullable:false})
    @Type(() => SessionCreateWithoutUserInput)
    create!: InstanceType<typeof SessionCreateWithoutUserInput>;
}

@InputType()
export class SessionCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateInput {
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => UserCreateNestedOneWithoutSessionsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutSessionsInput>;
}

@ArgsType()
export class SessionGroupByArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithAggregationInput>;
    @Field(() => [SessionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof SessionScalarFieldEnum>;
    @Field(() => SessionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof SessionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SessionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregateInput>;
    @Field(() => SessionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregateInput>;
    @Field(() => SessionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregateInput>;
    @Field(() => SessionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregateInput>;
    @Field(() => SessionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregateInput>;
}

@ObjectType()
export class SessionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => SessionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregate>;
    @Field(() => SessionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregate>;
    @Field(() => SessionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregate>;
    @Field(() => SessionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregate>;
    @Field(() => SessionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregate>;
}

@InputType()
export class SessionListRelationFilter {
    @Field(() => SessionWhereInput, {nullable:true})
    every?: InstanceType<typeof SessionWhereInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    some?: InstanceType<typeof SessionWhereInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    none?: InstanceType<typeof SessionWhereInput>;
}

@InputType()
export class SessionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => Date, {nullable:true})
    expiresAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    device?: string;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => Date, {nullable:true})
    expiresAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    device?: string;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class SessionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
    @Field(() => SessionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountOrderByAggregateInput>;
    @Field(() => SessionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgOrderByAggregateInput>;
    @Field(() => SessionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxOrderByAggregateInput>;
    @Field(() => SessionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinOrderByAggregateInput>;
    @Field(() => SessionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumOrderByAggregateInput>;
}

@InputType()
export class SessionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class SessionScalarWhereWithAggregatesInput {
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    token?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    device?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatWithAggregatesFilter>;
}

@InputType()
export class SessionScalarWhereInput {
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    AND?: Array<SessionScalarWhereInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    OR?: Array<SessionScalarWhereInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    NOT?: Array<SessionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    token?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
}

@InputType()
export class SessionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
}

@InputType()
export class SessionUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => [SessionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<SessionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<SessionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [SessionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<SessionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    @Type(() => SessionScalarWhereInput)
    deleteMany?: Array<SessionScalarWhereInput>;
}

@InputType()
export class SessionUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateManyWithWhereWithoutUserInput {
    @Field(() => SessionScalarWhereInput, {nullable:false})
    @Type(() => SessionScalarWhereInput)
    where!: InstanceType<typeof SessionScalarWhereInput>;
    @Field(() => SessionUpdateManyMutationInput, {nullable:false})
    @Type(() => SessionUpdateManyMutationInput)
    data!: InstanceType<typeof SessionUpdateManyMutationInput>;
}

@InputType()
export class SessionUpdateManyWithoutUserNestedInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => [SessionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<SessionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<SessionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [SessionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<SessionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    @Type(() => SessionScalarWhereInput)
    deleteMany?: Array<SessionScalarWhereInput>;
}

@InputType()
export class SessionUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionUpdateWithoutUserInput, {nullable:false})
    @Type(() => SessionUpdateWithoutUserInput)
    data!: InstanceType<typeof SessionUpdateWithoutUserInput>;
}

@InputType()
export class SessionUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutSessionsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutSessionsNestedInput>;
}

@InputType()
export class SessionUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionUpdateWithoutUserInput, {nullable:false})
    @Type(() => SessionUpdateWithoutUserInput)
    update!: InstanceType<typeof SessionUpdateWithoutUserInput>;
    @Field(() => SessionCreateWithoutUserInput, {nullable:false})
    @Type(() => SessionCreateWithoutUserInput)
    create!: InstanceType<typeof SessionCreateWithoutUserInput>;
}

@InputType()
export class SessionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => [SessionWhereInput], {nullable:true})
    AND?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    OR?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    NOT?: Array<SessionWhereInput>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class SessionWhereInput {
    @Field(() => [SessionWhereInput], {nullable:true})
    AND?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    OR?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    NOT?: Array<SessionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    token?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class Session {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
}

@ArgsType()
export class UpdateManySessionArgs {
    @Field(() => SessionUpdateManyMutationInput, {nullable:false})
    @Type(() => SessionUpdateManyMutationInput)
    data!: InstanceType<typeof SessionUpdateManyMutationInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
}

@ArgsType()
export class UpdateOneSessionArgs {
    @Field(() => SessionUpdateInput, {nullable:false})
    @Type(() => SessionUpdateInput)
    data!: InstanceType<typeof SessionUpdateInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class UpsertOneSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionCreateInput, {nullable:false})
    @Type(() => SessionCreateInput)
    create!: InstanceType<typeof SessionCreateInput>;
    @Field(() => SessionUpdateInput, {nullable:false})
    @Type(() => SessionUpdateInput)
    update!: InstanceType<typeof SessionUpdateInput>;
}

@ObjectType()
export class AggregateShipping {
    @Field(() => ShippingCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregate>;
    @Field(() => ShippingAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregate>;
    @Field(() => ShippingSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregate>;
    @Field(() => ShippingMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregate>;
    @Field(() => ShippingMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregate>;
}

@ArgsType()
export class CreateManyShippingArgs {
    @Field(() => [ShippingCreateManyInput], {nullable:false})
    @Type(() => ShippingCreateManyInput)
    data!: Array<ShippingCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneShippingArgs {
    @Field(() => ShippingCreateInput, {nullable:false})
    @Type(() => ShippingCreateInput)
    data!: InstanceType<typeof ShippingCreateInput>;
}

@ArgsType()
export class DeleteManyShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@ArgsType()
export class DeleteOneShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class FindFirstShippingOrThrowArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindFirstShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindManyShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueShippingOrThrowArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class FindUniqueShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class ShippingAggregateArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ShippingCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregateInput>;
    @Field(() => ShippingAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregateInput>;
    @Field(() => ShippingSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregateInput>;
    @Field(() => ShippingMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregateInput>;
    @Field(() => ShippingMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregateInput>;
}

@InputType()
export class ShippingAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ShippingAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    orderId?: number;
}

@InputType()
export class ShippingAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ShippingCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @Field(() => Boolean, {nullable:true})
    shippingStatus?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ShippingCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    logisticName!: number;
    @Field(() => Int, {nullable:false})
    deliveryDate!: number;
    @Field(() => Int, {nullable:false})
    shippingStatus!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    courier!: number;
    @Field(() => Int, {nullable:false})
    estimatedTime!: number;
    @Field(() => Int, {nullable:false})
    trackingNo!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ShippingCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingStatus?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingCreateNestedOneWithoutAddressInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingCreateNestedOneWithoutOrderInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingCreateOrConnectWithoutAddressInput {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingCreateWithoutAddressInput)
    create!: InstanceType<typeof ShippingCreateWithoutAddressInput>;
}

@InputType()
export class ShippingCreateOrConnectWithoutOrderInput {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingCreateWithoutOrderInput)
    create!: InstanceType<typeof ShippingCreateWithoutOrderInput>;
}

@InputType()
export class ShippingCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutShippingInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutShippingInput>;
}

@InputType()
export class ShippingCreateWithoutOrderInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutShippingInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutShippingInput>;
}

@InputType()
export class ShippingCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutShippingInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutShippingInput>;
    @Field(() => OrderCreateNestedOneWithoutShippingInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutShippingInput>;
}

@ArgsType()
export class ShippingGroupByArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithAggregationInput>;
    @Field(() => [ShippingScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ShippingScalarFieldEnum>;
    @Field(() => ShippingScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ShippingScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ShippingCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregateInput>;
    @Field(() => ShippingAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregateInput>;
    @Field(() => ShippingSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregateInput>;
    @Field(() => ShippingMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregateInput>;
    @Field(() => ShippingMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregateInput>;
}

@ObjectType()
export class ShippingGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ShippingCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregate>;
    @Field(() => ShippingAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregate>;
    @Field(() => ShippingSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregate>;
    @Field(() => ShippingMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregate>;
    @Field(() => ShippingMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregate>;
}

@InputType()
export class ShippingMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @Field(() => Boolean, {nullable:true})
    shippingStatus?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ShippingMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    logisticName?: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:true})
    shippingStatus?: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingStatus?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @Field(() => Boolean, {nullable:true})
    shippingStatus?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ShippingMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    logisticName?: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:true})
    shippingStatus?: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingStatus?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingNullableRelationFilter {
    @Field(() => ShippingWhereInput, {nullable:true})
    is?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deliveryDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    shippingStatus?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    courier?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    estimatedTime?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    trackingNo?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ShippingCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountOrderByAggregateInput>;
    @Field(() => ShippingAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgOrderByAggregateInput>;
    @Field(() => ShippingMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxOrderByAggregateInput>;
    @Field(() => ShippingMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinOrderByAggregateInput>;
    @Field(() => ShippingSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumOrderByAggregateInput>;
}

@InputType()
export class ShippingOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deliveryDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    shippingStatus?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    courier?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    estimatedTime?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    trackingNo?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    order?: InstanceType<typeof OrderOrderByWithRelationInput>;
}

@InputType()
export class ShippingScalarWhereWithAggregatesInput {
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => EnumShippingStatusWithAggregatesFilter, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    orderId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ShippingSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ShippingSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
}

@InputType()
export class ShippingSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ShippingUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingUncheckedCreateNestedOneWithoutOrderInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingUpsertWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class ShippingUncheckedUpdateOneWithoutOrderNestedInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingUpsertWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutOrderInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutOrderInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutOrderInput>;
}

@InputType()
export class ShippingUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUpdateOneWithoutAddressNestedInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingUpsertWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class ShippingUpdateOneWithoutOrderNestedInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingUpsertWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutOrderInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutOrderInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutOrderInput>;
}

@InputType()
export class ShippingUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingUpdateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutAddressInput)
    data!: InstanceType<typeof ShippingUpdateWithoutAddressInput>;
}

@InputType()
export class ShippingUpdateToOneWithWhereWithoutOrderInput {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutOrderInput)
    data!: InstanceType<typeof ShippingUpdateWithoutOrderInput>;
}

@InputType()
export class ShippingUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpdateWithoutOrderInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumShippingStatusFieldUpdateOperationsInput, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutShippingNestedInput>;
    @Field(() => OrderUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpsertWithoutAddressInput {
    @Field(() => ShippingUpdateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutAddressInput)
    update!: InstanceType<typeof ShippingUpdateWithoutAddressInput>;
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingCreateWithoutAddressInput)
    create!: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingUpsertWithoutOrderInput {
    @Field(() => ShippingUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutOrderInput)
    update!: InstanceType<typeof ShippingUpdateWithoutOrderInput>;
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingCreateWithoutOrderInput)
    create!: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => [ShippingWhereInput], {nullable:true})
    AND?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    OR?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    NOT?: Array<ShippingWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumShippingStatusFilter, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@InputType()
export class ShippingWhereInput {
    @Field(() => [ShippingWhereInput], {nullable:true})
    AND?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    OR?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    NOT?: Array<ShippingWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumShippingStatusFilter, {nullable:true})
    shippingStatus?: InstanceType<typeof EnumShippingStatusFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@ObjectType()
export class Shipping {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate!: Date | null;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier!: string | null;
    @Field(() => String, {nullable:true})
    estimatedTime!: string | null;
    @Field(() => String, {nullable:true})
    trackingNo!: string | null;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => Order, {nullable:false})
    order?: InstanceType<typeof Order>;
}

@ArgsType()
export class UpdateManyShippingArgs {
    @Field(() => ShippingUpdateManyMutationInput, {nullable:false})
    @Type(() => ShippingUpdateManyMutationInput)
    data!: InstanceType<typeof ShippingUpdateManyMutationInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@ArgsType()
export class UpdateOneShippingArgs {
    @Field(() => ShippingUpdateInput, {nullable:false})
    @Type(() => ShippingUpdateInput)
    data!: InstanceType<typeof ShippingUpdateInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class UpsertOneShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateInput, {nullable:false})
    @Type(() => ShippingCreateInput)
    create!: InstanceType<typeof ShippingCreateInput>;
    @Field(() => ShippingUpdateInput, {nullable:false})
    @Type(() => ShippingUpdateInput)
    update!: InstanceType<typeof ShippingUpdateInput>;
}

@ObjectType()
export class AggregateTransaction {
    @Field(() => TransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregate>;
    @Field(() => TransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregate>;
    @Field(() => TransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregate>;
    @Field(() => TransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregate>;
    @Field(() => TransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregate>;
}

@ArgsType()
export class CreateManyTransactionArgs {
    @Field(() => [TransactionCreateManyInput], {nullable:false})
    @Type(() => TransactionCreateManyInput)
    data!: Array<TransactionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneTransactionArgs {
    @Field(() => TransactionCreateInput, {nullable:false})
    @Type(() => TransactionCreateInput)
    data!: InstanceType<typeof TransactionCreateInput>;
}

@ArgsType()
export class DeleteManyTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@ArgsType()
export class DeleteOneTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
}

@ArgsType()
export class FindFirstTransactionOrThrowArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindManyTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueTransactionOrThrowArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
}

@ArgsType()
export class FindUniqueTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
}

@ArgsType()
export class TransactionAggregateArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => TransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregateInput>;
    @Field(() => TransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregateInput>;
    @Field(() => TransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregateInput>;
    @Field(() => TransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregateInput>;
    @Field(() => TransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregateInput>;
}

@InputType()
export class TransactionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class TransactionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Float, {nullable:true})
    accountId?: number;
}

@InputType()
export class TransactionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class TransactionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class TransactionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    transactionType!: number;
    @Field(() => Int, {nullable:false})
    transactionCategory!: number;
    @Field(() => Int, {nullable:false})
    currentBalance!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class TransactionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionCreateManyAccountInputEnvelope {
    @Field(() => [TransactionCreateManyAccountInput], {nullable:false})
    @Type(() => TransactionCreateManyAccountInput)
    data!: Array<TransactionCreateManyAccountInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class TransactionCreateManyAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateManyUserInputEnvelope {
    @Field(() => [TransactionCreateManyUserInput], {nullable:false})
    @Type(() => TransactionCreateManyUserInput)
    data!: Array<TransactionCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class TransactionCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateNestedManyWithoutAccountInput {
    @Field(() => [TransactionCreateWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutAccountInput)
    create?: Array<TransactionCreateWithoutAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutAccountInput>;
    @Field(() => TransactionCreateManyAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
}

@InputType()
export class TransactionCreateNestedManyWithoutUserInput {
    @Field(() => [TransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateWithoutUserInput)
    create?: Array<TransactionCreateWithoutUserInput>;
    @Field(() => [TransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutUserInput>;
    @Field(() => TransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyUserInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
}

@InputType()
export class TransactionCreateNestedOneWithoutPaymentInput {
    @Field(() => TransactionCreateWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutPaymentInput)
    create?: InstanceType<typeof TransactionCreateWithoutPaymentInput>;
    @Field(() => TransactionCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutPaymentInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
}

@InputType()
export class TransactionCreateOrConnectWithoutAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionCreateWithoutAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutAccountInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutPaymentInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionCreateWithoutPaymentInput, {nullable:false})
    @Type(() => TransactionCreateWithoutPaymentInput)
    create!: InstanceType<typeof TransactionCreateWithoutPaymentInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutUserInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => TransactionCreateWithoutUserInput)
    create!: InstanceType<typeof TransactionCreateWithoutUserInput>;
}

@InputType()
export class TransactionCreateWithoutAccountInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutTransactionsInput, {nullable:false})
    User!: InstanceType<typeof UserCreateNestedOneWithoutTransactionsInput>;
    @Field(() => PaymentCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateWithoutPaymentInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutTransactionsInput, {nullable:false})
    User!: InstanceType<typeof UserCreateNestedOneWithoutTransactionsInput>;
    @Field(() => AccountCreateNestedOneWithoutTransactionsInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionsInput>;
}

@InputType()
export class TransactionCreateWithoutUserInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => AccountCreateNestedOneWithoutTransactionsInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionsInput>;
    @Field(() => PaymentCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutTransactionsInput, {nullable:false})
    User!: InstanceType<typeof UserCreateNestedOneWithoutTransactionsInput>;
    @Field(() => AccountCreateNestedOneWithoutTransactionsInput, {nullable:false})
    account!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionsInput>;
    @Field(() => PaymentCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentCreateNestedOneWithoutTransactionInput>;
}

@ArgsType()
export class TransactionGroupByArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithAggregationInput>;
    @Field(() => [TransactionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof TransactionScalarFieldEnum>;
    @Field(() => TransactionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof TransactionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => TransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregateInput>;
    @Field(() => TransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregateInput>;
    @Field(() => TransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregateInput>;
    @Field(() => TransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregateInput>;
    @Field(() => TransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregateInput>;
}

@ObjectType()
export class TransactionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => TransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregate>;
    @Field(() => TransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregate>;
    @Field(() => TransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregate>;
    @Field(() => TransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregate>;
    @Field(() => TransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregate>;
}

@InputType()
export class TransactionListRelationFilter {
    @Field(() => TransactionWhereInput, {nullable:true})
    every?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    some?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    none?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class TransactionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:true})
    transactionCategory?: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class TransactionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:true})
    transactionCategory?: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class TransactionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => TransactionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountOrderByAggregateInput>;
    @Field(() => TransactionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgOrderByAggregateInput>;
    @Field(() => TransactionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxOrderByAggregateInput>;
    @Field(() => TransactionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinOrderByAggregateInput>;
    @Field(() => TransactionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumOrderByAggregateInput>;
}

@InputType()
export class TransactionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    User?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    account?: InstanceType<typeof AccountOrderByWithRelationInput>;
    @Field(() => PaymentOrderByWithRelationInput, {nullable:true})
    payment?: InstanceType<typeof PaymentOrderByWithRelationInput>;
}

@InputType()
export class TransactionRelationFilter {
    @Field(() => TransactionWhereInput, {nullable:true})
    is?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    isNot?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionScalarWhereWithAggregatesInput {
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => EnumTransactionStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusWithAggregatesFilter>;
    @Field(() => EnumTransactionTypeWithAggregatesFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeWithAggregatesFilter>;
    @Field(() => EnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    accountId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class TransactionScalarWhereInput {
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    AND?: Array<TransactionScalarWhereInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    OR?: Array<TransactionScalarWhereInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    NOT?: Array<TransactionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class TransactionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class TransactionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class TransactionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class TransactionUncheckedCreateNestedManyWithoutAccountInput {
    @Field(() => [TransactionCreateWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutAccountInput)
    create?: Array<TransactionCreateWithoutAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutAccountInput>;
    @Field(() => TransactionCreateManyAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
}

@InputType()
export class TransactionUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [TransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateWithoutUserInput)
    create?: Array<TransactionCreateWithoutUserInput>;
    @Field(() => [TransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutUserInput>;
    @Field(() => TransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyUserInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
}

@InputType()
export class TransactionUncheckedCreateWithoutAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentUncheckedCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionUncheckedCreateWithoutPaymentInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentUncheckedCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => PaymentUncheckedCreateNestedOneWithoutTransactionInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutAccountNestedInput {
    @Field(() => [TransactionCreateWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutAccountInput)
    create?: Array<TransactionCreateWithoutAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutAccountInput>;
    @Field(() => TransactionCreateManyAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [TransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateWithoutUserInput)
    create?: Array<TransactionCreateWithoutUserInput>;
    @Field(() => [TransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => TransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyUserInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentUncheckedUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutPaymentInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentUncheckedUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => PaymentUncheckedUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUncheckedUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUpdateManyWithWhereWithoutAccountInput {
    @Field(() => TransactionScalarWhereInput, {nullable:false})
    @Type(() => TransactionScalarWhereInput)
    where!: InstanceType<typeof TransactionScalarWhereInput>;
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
}

@InputType()
export class TransactionUpdateManyWithWhereWithoutUserInput {
    @Field(() => TransactionScalarWhereInput, {nullable:false})
    @Type(() => TransactionScalarWhereInput)
    where!: InstanceType<typeof TransactionScalarWhereInput>;
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
}

@InputType()
export class TransactionUpdateManyWithoutAccountNestedInput {
    @Field(() => [TransactionCreateWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutAccountInput)
    create?: Array<TransactionCreateWithoutAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutAccountInput>;
    @Field(() => TransactionCreateManyAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUpdateManyWithoutUserNestedInput {
    @Field(() => [TransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateWithoutUserInput)
    create?: Array<TransactionCreateWithoutUserInput>;
    @Field(() => [TransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => TransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyUserInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUpdateOneRequiredWithoutPaymentNestedInput {
    @Field(() => TransactionCreateWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutPaymentInput)
    create?: InstanceType<typeof TransactionCreateWithoutPaymentInput>;
    @Field(() => TransactionCreateOrConnectWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutPaymentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutPaymentInput>;
    @Field(() => TransactionUpsertWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionUpsertWithoutPaymentInput)
    upsert?: InstanceType<typeof TransactionUpsertWithoutPaymentInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionUpdateToOneWithWhereWithoutPaymentInput, {nullable:true})
    @Type(() => TransactionUpdateToOneWithWhereWithoutPaymentInput)
    update?: InstanceType<typeof TransactionUpdateToOneWithWhereWithoutPaymentInput>;
}

@InputType()
export class TransactionUpdateToOneWithWhereWithoutPaymentInput {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionUpdateWithoutPaymentInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutPaymentInput)
    data!: InstanceType<typeof TransactionUpdateWithoutPaymentInput>;
}

@InputType()
export class TransactionUpdateWithWhereUniqueWithoutAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionUpdateWithoutAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutAccountInput)
    data!: InstanceType<typeof TransactionUpdateWithoutAccountInput>;
}

@InputType()
export class TransactionUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutUserInput)
    data!: InstanceType<typeof TransactionUpdateWithoutUserInput>;
}

@InputType()
export class TransactionUpdateWithoutAccountInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    User?: InstanceType<typeof UserUpdateOneRequiredWithoutTransactionsNestedInput>;
    @Field(() => PaymentUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutPaymentInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    User?: InstanceType<typeof UserUpdateOneRequiredWithoutTransactionsNestedInput>;
    @Field(() => AccountUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionsNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutUserInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AccountUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionsNestedInput>;
    @Field(() => PaymentUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    User?: InstanceType<typeof UserUpdateOneRequiredWithoutTransactionsNestedInput>;
    @Field(() => AccountUpdateOneRequiredWithoutTransactionsNestedInput, {nullable:true})
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionsNestedInput>;
    @Field(() => PaymentUpdateOneWithoutTransactionNestedInput, {nullable:true})
    payment?: InstanceType<typeof PaymentUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpsertWithWhereUniqueWithoutAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionUpdateWithoutAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutAccountInput)
    update!: InstanceType<typeof TransactionUpdateWithoutAccountInput>;
    @Field(() => TransactionCreateWithoutAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutAccountInput>;
}

@InputType()
export class TransactionUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutUserInput)
    update!: InstanceType<typeof TransactionUpdateWithoutUserInput>;
    @Field(() => TransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => TransactionCreateWithoutUserInput)
    create!: InstanceType<typeof TransactionCreateWithoutUserInput>;
}

@InputType()
export class TransactionUpsertWithoutPaymentInput {
    @Field(() => TransactionUpdateWithoutPaymentInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutPaymentInput)
    update!: InstanceType<typeof TransactionUpdateWithoutPaymentInput>;
    @Field(() => TransactionCreateWithoutPaymentInput, {nullable:false})
    @Type(() => TransactionCreateWithoutPaymentInput)
    create!: InstanceType<typeof TransactionCreateWithoutPaymentInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => [TransactionWhereInput], {nullable:true})
    AND?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    OR?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    NOT?: Array<TransactionWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => PaymentNullableRelationFilter, {nullable:true})
    payment?: InstanceType<typeof PaymentNullableRelationFilter>;
}

@InputType()
export class TransactionWhereInput {
    @Field(() => [TransactionWhereInput], {nullable:true})
    AND?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    OR?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    NOT?: Array<TransactionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => PaymentNullableRelationFilter, {nullable:true})
    payment?: InstanceType<typeof PaymentNullableRelationFilter>;
}

@ObjectType()
export class Transaction {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => User, {nullable:false})
    User?: InstanceType<typeof User>;
    @Field(() => Account, {nullable:false})
    account?: InstanceType<typeof Account>;
    @Field(() => Payment, {nullable:true})
    payment?: InstanceType<typeof Payment> | null;
}

@ArgsType()
export class UpdateManyTransactionArgs {
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@ArgsType()
export class UpdateOneTransactionArgs {
    @Field(() => TransactionUpdateInput, {nullable:false})
    @Type(() => TransactionUpdateInput)
    data!: InstanceType<typeof TransactionUpdateInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
}

@ArgsType()
export class UpsertOneTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'userId' | 'accountId'>;
    @Field(() => TransactionCreateInput, {nullable:false})
    @Type(() => TransactionCreateInput)
    create!: InstanceType<typeof TransactionCreateInput>;
    @Field(() => TransactionUpdateInput, {nullable:false})
    @Type(() => TransactionUpdateInput)
    update!: InstanceType<typeof TransactionUpdateInput>;
}

@ObjectType()
export class AggregateUser {
    @Field(() => UserCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregate>;
    @Field(() => UserAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregate>;
    @Field(() => UserSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregate>;
    @Field(() => UserMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregate>;
    @Field(() => UserMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregate>;
}

@ArgsType()
export class CreateManyUserArgs {
    @Field(() => [UserCreateManyInput], {nullable:false})
    @Type(() => UserCreateManyInput)
    data!: Array<UserCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneUserArgs {
    @Field(() => UserCreateInput, {nullable:false})
    @Type(() => UserCreateInput)
    data!: InstanceType<typeof UserCreateInput>;
}

@ArgsType()
export class DeleteManyUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class DeleteOneUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@ArgsType()
export class FindFirstUserOrThrowArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindFirstUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindManyUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueUserOrThrowArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@ArgsType()
export class FindUniqueUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@ArgsType()
export class UpdateManyUserArgs {
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class UpdateOneUserArgs {
    @Field(() => UserUpdateInput, {nullable:false})
    @Type(() => UserUpdateInput)
    data!: InstanceType<typeof UserUpdateInput>;
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@ArgsType()
export class UpsertOneUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateInput, {nullable:false})
    @Type(() => UserCreateInput)
    create!: InstanceType<typeof UserCreateInput>;
    @Field(() => UserUpdateInput, {nullable:false})
    @Type(() => UserUpdateInput)
    update!: InstanceType<typeof UserUpdateInput>;
}

@ArgsType()
export class UserAggregateArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregateInput>;
    @Field(() => UserAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregateInput>;
    @Field(() => UserSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregateInput>;
    @Field(() => UserMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregateInput>;
    @Field(() => UserMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@InputType()
export class UserAvgAggregateInput {
    @HideField()
    addressId?: true;
    @HideField()
    schoolId?: true;
}

@ObjectType()
export class UserAvgAggregate {
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    schoolId?: number;
}

@InputType()
export class UserAvgOrderByAggregateInput {
    @HideField()
    addressId?: keyof typeof SortOrder;
    @HideField()
    schoolId?: keyof typeof SortOrder;
}

@InputType()
export class UserCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @HideField()
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @HideField()
    referredById?: true;
    @HideField()
    status?: true;
    @HideField()
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class UserCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    firstName!: number;
    @Field(() => Int, {nullable:false})
    lastName!: number;
    @Field(() => Int, {nullable:false})
    email!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    userRole!: number;
    @Field(() => Int, {nullable:false})
    userType!: number;
    @Field(() => Int, {nullable:false})
    avatarUrl!: number;
    @Field(() => Int, {nullable:false})
    whatsappNumber!: number;
    @Field(() => Int, {nullable:false})
    whatsappVerifiedAt!: number;
    @HideField()
    password!: number;
    @Field(() => Int, {nullable:false})
    referredById!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    schoolId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    deletedAt!: number;
    @Field(() => Int, {nullable:false})
    theme!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class UserCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @HideField()
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @HideField()
    status?: keyof typeof SortOrder;
    @HideField()
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@ObjectType()
export class UserCount {
    @Field(() => Int, {nullable:false})
    referredUsers?: number;
    @Field(() => Int, {nullable:false})
    checkIns?: number;
    @Field(() => Int, {nullable:false})
    accounts?: number;
    @Field(() => Int, {nullable:false})
    transactions?: number;
    @Field(() => Int, {nullable:false})
    PointTransactions?: number;
    @Field(() => Int, {nullable:false})
    orders?: number;
    @Field(() => Int, {nullable:false})
    sessions?: number;
    @Field(() => Int, {nullable:false})
    hotelsCreated?: number;
    @Field(() => Int, {nullable:false})
    programsParticipation?: number;
    @Field(() => Int, {nullable:false})
    projectsInvestment?: number;
    @Field(() => Int, {nullable:false})
    claimedRewards?: number;
    @Field(() => Int, {nullable:false})
    userNotifications?: number;
    @Field(() => Int, {nullable:false})
    programsCreated?: number;
    @Field(() => Int, {nullable:false})
    filesCreated?: number;
}

@InputType()
export class UserCreateManyReferredByInputEnvelope {
    @Field(() => [UserCreateManyReferredByInput], {nullable:false})
    @Type(() => UserCreateManyReferredByInput)
    data!: Array<UserCreateManyReferredByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserCreateManyReferredByInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateManySchoolInputEnvelope {
    @Field(() => [UserCreateManySchoolInput], {nullable:false})
    @Type(() => UserCreateManySchoolInput)
    data!: Array<UserCreateManySchoolInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserCreateManySchoolInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateManyInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateNestedManyWithoutClaimedRewardsInput {
    @Field(() => [UserCreateWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: Array<UserCreateWithoutClaimedRewardsInput>;
    @Field(() => [UserCreateOrConnectWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserCreateNestedManyWithoutProgramsParticipationInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserCreateNestedManyWithoutProjectsInvestmentInput {
    @Field(() => [UserCreateWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create?: Array<UserCreateWithoutProjectsInvestmentInput>;
    @Field(() => [UserCreateOrConnectWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProjectsInvestmentInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProjectsInvestmentInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserCreateNestedManyWithoutReferredByInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserCreateNestedManyWithoutSchoolInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserCreateNestedOneWithoutAccountsInput {
    @Field(() => UserCreateWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateWithoutAccountsInput)
    create?: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserCreateOrConnectWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAccountsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAccountsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutAddressInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutCheckInsInput {
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateWithoutCheckInsInput)
    create?: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutCheckInsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutFilesCreatedInput {
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutFilesCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutFilesCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutHotelsCreatedInput {
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutHotelsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutHotelsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutOrdersInput {
    @Field(() => UserCreateWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateWithoutOrdersInput)
    create?: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserCreateOrConnectWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutOrdersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutOrdersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutPointTransactionsInput {
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutPointTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPointTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutProgramsCreatedInput {
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProgramsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutReferredUsersInput {
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create?: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserCreateOrConnectWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredUsersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutReferredUsersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutSessionsInput {
    @Field(() => UserCreateWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateWithoutSessionsInput)
    create?: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserCreateOrConnectWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSessionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutSessionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutTransactionsInput {
    @Field(() => UserCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateNestedOneWithoutUserNotificationsInput {
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create?: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserCreateOrConnectWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutUserNotificationsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutUserNotificationsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserCreateOrConnectWithoutAccountsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutAccountsInput, {nullable:false})
    @Type(() => UserCreateWithoutAccountsInput)
    create!: InstanceType<typeof UserCreateWithoutAccountsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutAddressInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutAddressInput, {nullable:false})
    @Type(() => UserCreateWithoutAddressInput)
    create!: InstanceType<typeof UserCreateWithoutAddressInput>;
}

@InputType()
export class UserCreateOrConnectWithoutCheckInsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserCreateWithoutCheckInsInput)
    create!: InstanceType<typeof UserCreateWithoutCheckInsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutClaimedRewardsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create!: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutFilesCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutHotelsCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutOrdersInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutOrdersInput, {nullable:false})
    @Type(() => UserCreateWithoutOrdersInput)
    create!: InstanceType<typeof UserCreateWithoutOrdersInput>;
}

@InputType()
export class UserCreateOrConnectWithoutPointTransactionsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProgramsCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProjectsInvestmentInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutProjectsInvestmentInput, {nullable:false})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create!: InstanceType<typeof UserCreateWithoutProjectsInvestmentInput>;
}

@InputType()
export class UserCreateOrConnectWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutReferredByInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredByInput)
    create!: InstanceType<typeof UserCreateWithoutReferredByInput>;
}

@InputType()
export class UserCreateOrConnectWithoutReferredUsersInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create!: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
}

@InputType()
export class UserCreateOrConnectWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutSchoolInput, {nullable:false})
    @Type(() => UserCreateWithoutSchoolInput)
    create!: InstanceType<typeof UserCreateWithoutSchoolInput>;
}

@InputType()
export class UserCreateOrConnectWithoutSessionsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutSessionsInput, {nullable:false})
    @Type(() => UserCreateWithoutSessionsInput)
    create!: InstanceType<typeof UserCreateWithoutSessionsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutTransactionsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutTransactionsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutUserNotificationsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create!: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
}

@InputType()
export class UserCreateWithoutAccountsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutAddressInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutCheckInsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutClaimedRewardsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutFilesCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutHotelsCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutOrdersInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutPointTransactionsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutProgramsCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutProgramsParticipationInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutProjectsInvestmentInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutReferredByInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutReferredUsersInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutSchoolInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutSessionsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutTransactionsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutUserNotificationsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@ArgsType()
export class UserGroupByArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithAggregationInput>;
    @Field(() => [UserScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof UserScalarFieldEnum>;
    @Field(() => UserScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof UserScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregateInput>;
    @Field(() => UserAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregateInput>;
    @Field(() => UserSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregateInput>;
    @Field(() => UserMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregateInput>;
    @Field(() => UserMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@ObjectType()
export class UserGroupBy {
    @Field(() => String, {nullable:false})
    id!: string;
    @Field(() => String, {nullable:false})
    firstName!: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:false})
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password!: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:false})
    status!: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:false})
    theme!: keyof typeof Theme;
    @Field(() => UserCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregate>;
    @Field(() => UserAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregate>;
    @Field(() => UserSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregate>;
    @Field(() => UserMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregate>;
    @Field(() => UserMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregate>;
}

@InputType()
export class UserListRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    every?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    some?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    none?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @HideField()
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @HideField()
    referredById?: true;
    @HideField()
    status?: true;
    @HideField()
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
}

@ObjectType()
export class UserMaxAggregate {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    firstName?: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:true})
    email?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:true})
    userType?: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:true})
    whatsappNumber?: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password?: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @HideField()
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @HideField()
    status?: keyof typeof SortOrder;
    @HideField()
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@InputType()
export class UserMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @HideField()
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @HideField()
    referredById?: true;
    @HideField()
    status?: true;
    @HideField()
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
}

@ObjectType()
export class UserMinAggregate {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    firstName?: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:true})
    email?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:true})
    userType?: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:true})
    whatsappNumber?: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password?: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @HideField()
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @HideField()
    status?: keyof typeof SortOrder;
    @HideField()
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@InputType()
export class UserNullableRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    is?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    isNot?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class UserOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    lastName?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    avatarUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @HideField()
    referredById?: InstanceType<typeof SortOrderInput>;
    @HideField()
    status?: keyof typeof SortOrder;
    @HideField()
    schoolId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deletedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
    @Field(() => UserCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountOrderByAggregateInput>;
    @Field(() => UserAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgOrderByAggregateInput>;
    @Field(() => UserMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxOrderByAggregateInput>;
    @Field(() => UserMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinOrderByAggregateInput>;
    @Field(() => UserSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumOrderByAggregateInput>;
}

@InputType()
export class UserOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    lastName?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    avatarUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @HideField()
    referredById?: InstanceType<typeof SortOrderInput>;
    @HideField()
    status?: keyof typeof SortOrder;
    @HideField()
    schoolId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deletedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    referredBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserOrderByRelationAggregateInput>;
    @Field(() => CheckInOrderByRelationAggregateInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInOrderByRelationAggregateInput>;
    @Field(() => SchoolOrderByWithRelationInput, {nullable:true})
    school?: InstanceType<typeof SchoolOrderByWithRelationInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountOrderByRelationAggregateInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionOrderByRelationAggregateInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionOrderByRelationAggregateInput>;
    @HideField()
    orders?: InstanceType<typeof OrderOrderByRelationAggregateInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionOrderByRelationAggregateInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelOrderByRelationAggregateInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectOrderByRelationAggregateInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardOrderByRelationAggregateInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationOrderByRelationAggregateInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileOrderByRelationAggregateInput>;
}

@InputType()
export class UserRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    is?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    isNot?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserScalarWhereWithAggregatesInput {
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    firstName?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    email?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumUserRoleWithAggregatesFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
    @Field(() => EnumUserTypeWithAggregatesFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    password?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusWithAggregatesFilter>;
    @HideField()
    schoolId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => EnumThemeWithAggregatesFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeWithAggregatesFilter>;
}

@InputType()
export class UserScalarWhereInput {
    @Field(() => [UserScalarWhereInput], {nullable:true})
    AND?: Array<UserScalarWhereInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    OR?: Array<UserScalarWhereInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    NOT?: Array<UserScalarWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    id?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    email?: InstanceType<typeof StringFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFilter>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @HideField()
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
}

@InputType()
export class UserSumAggregateInput {
    @HideField()
    addressId?: true;
    @HideField()
    schoolId?: true;
}

@ObjectType()
export class UserSumAggregate {
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
}

@InputType()
export class UserSumOrderByAggregateInput {
    @HideField()
    addressId?: keyof typeof SortOrder;
    @HideField()
    schoolId?: keyof typeof SortOrder;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutClaimedRewardsInput {
    @Field(() => [UserCreateWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: Array<UserCreateWithoutClaimedRewardsInput>;
    @Field(() => [UserCreateOrConnectWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutProgramsParticipationInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutProjectsInvestmentInput {
    @Field(() => [UserCreateWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create?: Array<UserCreateWithoutProjectsInvestmentInput>;
    @Field(() => [UserCreateOrConnectWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProjectsInvestmentInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProjectsInvestmentInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutReferredByInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutSchoolInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
}

@InputType()
export class UserUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
}

@InputType()
export class UserUncheckedCreateWithoutAccountsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutAddressInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutCheckInsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutClaimedRewardsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutFilesCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutHotelsCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutOrdersInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutPointTransactionsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutProgramsCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutProgramsParticipationInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutProjectsInvestmentInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutReferredByInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutReferredUsersInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutSchoolInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutSessionsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutTransactionsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutUserNotificationsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @HideField()
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedCreateNestedManyWithoutInvestorsInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedCreateNestedManyWithoutClaimersInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutClaimedRewardsNestedInput {
    @Field(() => [UserCreateWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: Array<UserCreateWithoutClaimedRewardsInput>;
    @Field(() => [UserCreateOrConnectWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutClaimedRewardsInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutClaimedRewardsInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutClaimedRewardsInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutClaimedRewardsInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutClaimedRewardsInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutClaimedRewardsInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutClaimedRewardsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProgramsParticipationInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProgramsParticipationInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProgramsParticipationInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProgramsParticipationInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProgramsParticipationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProjectsInvestmentNestedInput {
    @Field(() => [UserCreateWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create?: Array<UserCreateWithoutProjectsInvestmentInput>;
    @Field(() => [UserCreateOrConnectWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProjectsInvestmentInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProjectsInvestmentInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProjectsInvestmentInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProjectsInvestmentInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProjectsInvestmentInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutReferredByNestedInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutReferredByInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutReferredByInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutReferredByInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutReferredByInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutReferredByInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutReferredByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutSchoolNestedInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutSchoolInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutSchoolInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutSchoolInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutSchoolInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutSchoolInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserUpsertWithoutAddressInput, {nullable:true})
    @Type(() => UserUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutAccountsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutCheckInsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutClaimedRewardsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutFilesCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutHotelsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutOrdersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutPointTransactionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutProgramsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutProgramsParticipationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutProjectsInvestmentInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutReferredByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutReferredUsersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutSessionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutTransactionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutUserNotificationsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUncheckedUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUncheckedUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutClaimedRewardsInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutProgramsParticipationInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutProjectsInvestmentInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutReferredByInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutSchoolInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithoutClaimedRewardsNestedInput {
    @Field(() => [UserCreateWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: Array<UserCreateWithoutClaimedRewardsInput>;
    @Field(() => [UserCreateOrConnectWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutClaimedRewardsInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutClaimedRewardsInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutClaimedRewardsInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutClaimedRewardsInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutClaimedRewardsInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutClaimedRewardsInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutClaimedRewardsInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutProgramsParticipationNestedInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProgramsParticipationInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProgramsParticipationInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProgramsParticipationInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProgramsParticipationInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutProjectsInvestmentNestedInput {
    @Field(() => [UserCreateWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create?: Array<UserCreateWithoutProjectsInvestmentInput>;
    @Field(() => [UserCreateOrConnectWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProjectsInvestmentInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProjectsInvestmentInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProjectsInvestmentInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProjectsInvestmentInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProjectsInvestmentInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutReferredByNestedInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutReferredByInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutReferredByInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutReferredByInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutReferredByInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutReferredByInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutSchoolNestedInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutSchoolInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutSchoolInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutSchoolInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutSchoolInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutSchoolInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutAccountsNestedInput {
    @Field(() => UserCreateWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateWithoutAccountsInput)
    create?: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserCreateOrConnectWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAccountsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAccountsInput>;
    @Field(() => UserUpsertWithoutAccountsInput, {nullable:true})
    @Type(() => UserUpsertWithoutAccountsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAccountsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAccountsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAccountsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAccountsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutCheckInsNestedInput {
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateWithoutCheckInsInput)
    create?: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutCheckInsInput>;
    @Field(() => UserUpsertWithoutCheckInsInput, {nullable:true})
    @Type(() => UserUpsertWithoutCheckInsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutCheckInsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutCheckInsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutCheckInsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutCheckInsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutFilesCreatedNestedInput {
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutFilesCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutFilesCreatedInput>;
    @Field(() => UserUpsertWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutFilesCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutFilesCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutFilesCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutFilesCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutHotelsCreatedNestedInput {
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutHotelsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutHotelsCreatedInput>;
    @Field(() => UserUpsertWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutHotelsCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutHotelsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutHotelsCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutHotelsCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutOrdersNestedInput {
    @Field(() => UserCreateWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateWithoutOrdersInput)
    create?: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserCreateOrConnectWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutOrdersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutOrdersInput>;
    @Field(() => UserUpsertWithoutOrdersInput, {nullable:true})
    @Type(() => UserUpsertWithoutOrdersInput)
    upsert?: InstanceType<typeof UserUpsertWithoutOrdersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutOrdersInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutOrdersInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutOrdersInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutPointTransactionsNestedInput {
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutPointTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPointTransactionsInput>;
    @Field(() => UserUpsertWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserUpsertWithoutPointTransactionsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutPointTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutPointTransactionsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutPointTransactionsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutProgramsCreatedNestedInput {
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProgramsCreatedInput>;
    @Field(() => UserUpsertWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutProgramsCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutProgramsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutProgramsCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutProgramsCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutSessionsNestedInput {
    @Field(() => UserCreateWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateWithoutSessionsInput)
    create?: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserCreateOrConnectWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSessionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutSessionsInput>;
    @Field(() => UserUpsertWithoutSessionsInput, {nullable:true})
    @Type(() => UserUpsertWithoutSessionsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutSessionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutSessionsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutSessionsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutSessionsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutTransactionsNestedInput {
    @Field(() => UserCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutTransactionsInput>;
    @Field(() => UserUpsertWithoutTransactionsInput, {nullable:true})
    @Type(() => UserUpsertWithoutTransactionsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutTransactionsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutTransactionsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutTransactionsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutUserNotificationsNestedInput {
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create?: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserCreateOrConnectWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutUserNotificationsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutUserNotificationsInput>;
    @Field(() => UserUpsertWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserUpsertWithoutUserNotificationsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutUserNotificationsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutUserNotificationsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutUserNotificationsInput>;
}

@InputType()
export class UserUpdateOneWithoutAddressNestedInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserUpsertWithoutAddressInput, {nullable:true})
    @Type(() => UserUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class UserUpdateOneWithoutReferredUsersNestedInput {
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create?: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserCreateOrConnectWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredUsersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutReferredUsersInput>;
    @Field(() => UserUpsertWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserUpsertWithoutReferredUsersInput)
    upsert?: InstanceType<typeof UserUpsertWithoutReferredUsersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateToOneWithWhereWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutReferredUsersInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutReferredUsersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAccountsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutAccountsInput, {nullable:false})
    @Type(() => UserUpdateWithoutAccountsInput)
    data!: InstanceType<typeof UserUpdateWithoutAccountsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutAddressInput, {nullable:false})
    @Type(() => UserUpdateWithoutAddressInput)
    data!: InstanceType<typeof UserUpdateWithoutAddressInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutCheckInsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserUpdateWithoutCheckInsInput)
    data!: InstanceType<typeof UserUpdateWithoutCheckInsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutFilesCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutFilesCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutFilesCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutHotelsCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutHotelsCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutHotelsCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutOrdersInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutOrdersInput, {nullable:false})
    @Type(() => UserUpdateWithoutOrdersInput)
    data!: InstanceType<typeof UserUpdateWithoutOrdersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutPointTransactionsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutPointTransactionsInput)
    data!: InstanceType<typeof UserUpdateWithoutPointTransactionsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutProgramsCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutProgramsCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutReferredUsersInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredUsersInput)
    data!: InstanceType<typeof UserUpdateWithoutReferredUsersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutSessionsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutSessionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutSessionsInput)
    data!: InstanceType<typeof UserUpdateWithoutSessionsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutTransactionsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutTransactionsInput)
    data!: InstanceType<typeof UserUpdateWithoutTransactionsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutUserNotificationsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserUpdateWithoutUserNotificationsInput)
    data!: InstanceType<typeof UserUpdateWithoutUserNotificationsInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutClaimedRewardsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserUpdateWithoutClaimedRewardsInput)
    data!: InstanceType<typeof UserUpdateWithoutClaimedRewardsInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsParticipationInput)
    data!: InstanceType<typeof UserUpdateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutProjectsInvestmentInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutProjectsInvestmentInput, {nullable:false})
    @Type(() => UserUpdateWithoutProjectsInvestmentInput)
    data!: InstanceType<typeof UserUpdateWithoutProjectsInvestmentInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutReferredByInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredByInput)
    data!: InstanceType<typeof UserUpdateWithoutReferredByInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => UserUpdateWithoutSchoolInput)
    data!: InstanceType<typeof UserUpdateWithoutSchoolInput>;
}

@InputType()
export class UserUpdateWithoutAccountsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutCheckInsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutClaimedRewardsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutFilesCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutHotelsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutOrdersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutPointTransactionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutProgramsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutProgramsParticipationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutProjectsInvestmentInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutReferredByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutReferredUsersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutSessionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutTransactionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutUserNotificationsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @Field(() => UserUpdateOneWithoutReferredUsersNestedInput, {nullable:true})
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => UserUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectUpdateManyWithoutInvestorsNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardUpdateManyWithoutClaimersNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutClaimedRewardsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserUpdateWithoutClaimedRewardsInput)
    update!: InstanceType<typeof UserUpdateWithoutClaimedRewardsInput>;
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create!: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsParticipationInput)
    update!: InstanceType<typeof UserUpdateWithoutProgramsParticipationInput>;
    @Field(() => UserCreateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutProjectsInvestmentInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutProjectsInvestmentInput, {nullable:false})
    @Type(() => UserUpdateWithoutProjectsInvestmentInput)
    update!: InstanceType<typeof UserUpdateWithoutProjectsInvestmentInput>;
    @Field(() => UserCreateWithoutProjectsInvestmentInput, {nullable:false})
    @Type(() => UserCreateWithoutProjectsInvestmentInput)
    create!: InstanceType<typeof UserCreateWithoutProjectsInvestmentInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutReferredByInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredByInput)
    update!: InstanceType<typeof UserUpdateWithoutReferredByInput>;
    @Field(() => UserCreateWithoutReferredByInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredByInput)
    create!: InstanceType<typeof UserCreateWithoutReferredByInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber'>;
    @Field(() => UserUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => UserUpdateWithoutSchoolInput)
    update!: InstanceType<typeof UserUpdateWithoutSchoolInput>;
    @Field(() => UserCreateWithoutSchoolInput, {nullable:false})
    @Type(() => UserCreateWithoutSchoolInput)
    create!: InstanceType<typeof UserCreateWithoutSchoolInput>;
}

@InputType()
export class UserUpsertWithoutAccountsInput {
    @Field(() => UserUpdateWithoutAccountsInput, {nullable:false})
    @Type(() => UserUpdateWithoutAccountsInput)
    update!: InstanceType<typeof UserUpdateWithoutAccountsInput>;
    @Field(() => UserCreateWithoutAccountsInput, {nullable:false})
    @Type(() => UserCreateWithoutAccountsInput)
    create!: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutAddressInput {
    @Field(() => UserUpdateWithoutAddressInput, {nullable:false})
    @Type(() => UserUpdateWithoutAddressInput)
    update!: InstanceType<typeof UserUpdateWithoutAddressInput>;
    @Field(() => UserCreateWithoutAddressInput, {nullable:false})
    @Type(() => UserCreateWithoutAddressInput)
    create!: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutCheckInsInput {
    @Field(() => UserUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserUpdateWithoutCheckInsInput)
    update!: InstanceType<typeof UserUpdateWithoutCheckInsInput>;
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserCreateWithoutCheckInsInput)
    create!: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutFilesCreatedInput {
    @Field(() => UserUpdateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutFilesCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutFilesCreatedInput>;
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutHotelsCreatedInput {
    @Field(() => UserUpdateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutHotelsCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutOrdersInput {
    @Field(() => UserUpdateWithoutOrdersInput, {nullable:false})
    @Type(() => UserUpdateWithoutOrdersInput)
    update!: InstanceType<typeof UserUpdateWithoutOrdersInput>;
    @Field(() => UserCreateWithoutOrdersInput, {nullable:false})
    @Type(() => UserCreateWithoutOrdersInput)
    create!: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutPointTransactionsInput {
    @Field(() => UserUpdateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutPointTransactionsInput)
    update!: InstanceType<typeof UserUpdateWithoutPointTransactionsInput>;
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutProgramsCreatedInput {
    @Field(() => UserUpdateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutReferredUsersInput {
    @Field(() => UserUpdateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredUsersInput)
    update!: InstanceType<typeof UserUpdateWithoutReferredUsersInput>;
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create!: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutSessionsInput {
    @Field(() => UserUpdateWithoutSessionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutSessionsInput)
    update!: InstanceType<typeof UserUpdateWithoutSessionsInput>;
    @Field(() => UserCreateWithoutSessionsInput, {nullable:false})
    @Type(() => UserCreateWithoutSessionsInput)
    create!: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutTransactionsInput {
    @Field(() => UserUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutTransactionsInput)
    update!: InstanceType<typeof UserUpdateWithoutTransactionsInput>;
    @Field(() => UserCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutTransactionsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutUserNotificationsInput {
    @Field(() => UserUpdateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserUpdateWithoutUserNotificationsInput)
    update!: InstanceType<typeof UserUpdateWithoutUserNotificationsInput>;
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create!: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserWhereUniqueInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    @Validator.IsEmail()
    email?: string;
    @HideField()
    addressId?: number;
    @Field(() => String, {nullable:true})
    @Validator.IsNotEmpty()
    whatsappNumber?: string;
    @Field(() => [UserWhereInput], {nullable:true})
    AND?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    OR?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    NOT?: Array<UserWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @HideField()
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    referredBy?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    referredUsers?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @HideField()
    accounts?: InstanceType<typeof AccountListRelationFilter>;
    @HideField()
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionListRelationFilter>;
    @HideField()
    orders?: InstanceType<typeof OrderListRelationFilter>;
    @HideField()
    sessions?: InstanceType<typeof SessionListRelationFilter>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelListRelationFilter>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectListRelationFilter>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardListRelationFilter>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationListRelationFilter>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    filesCreated?: InstanceType<typeof FileListRelationFilter>;
}

@InputType()
export class UserWhereInput {
    @Field(() => [UserWhereInput], {nullable:true})
    AND?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    OR?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    NOT?: Array<UserWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    id?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    email?: InstanceType<typeof StringFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFilter>;
    @HideField()
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @HideField()
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @HideField()
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    referredBy?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    referredUsers?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @HideField()
    accounts?: InstanceType<typeof AccountListRelationFilter>;
    @HideField()
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionListRelationFilter>;
    @HideField()
    orders?: InstanceType<typeof OrderListRelationFilter>;
    @HideField()
    sessions?: InstanceType<typeof SessionListRelationFilter>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelListRelationFilter>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    projectsInvestment?: InstanceType<typeof ProjectListRelationFilter>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardListRelationFilter>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationListRelationFilter>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    filesCreated?: InstanceType<typeof FileListRelationFilter>;
}

@ObjectType({isAbstract:true})
export class User {
    @Field(() => String, {nullable:false})
    id!: string;
    @Field(() => String, {nullable:false})
    firstName!: string;
    @Field(() => String, {nullable:true})
    lastName!: string | null;
    @Field(() => String, {nullable:false})
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:false,defaultValue:'MEMBER'})
    userRole!: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl!: string | null;
    @Field(() => String, {nullable:false})
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt!: Date | null;
    @HideField()
    password!: string;
    @Field(() => String, {nullable:true})
    referredById!: string | null;
    @Field(() => UserStatus, {nullable:false,defaultValue:'PENDING'})
    status!: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId!: number | null;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Date, {nullable:true})
    deletedAt!: Date | null;
    @Field(() => Theme, {nullable:false,defaultValue:'LIGHT'})
    theme!: keyof typeof Theme;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => User, {nullable:true})
    referredBy?: InstanceType<typeof User> | null;
    @Field(() => [User], {nullable:true})
    referredUsers?: Array<User>;
    @Field(() => [CheckIn], {nullable:true})
    checkIns?: Array<CheckIn>;
    @Field(() => School, {nullable:true})
    school?: InstanceType<typeof School> | null;
    @Field(() => [Account], {nullable:true})
    accounts?: Array<Account>;
    @Field(() => [Transaction], {nullable:true})
    transactions?: Array<Transaction>;
    @Field(() => [PointTransaction], {nullable:true})
    PointTransactions?: Array<PointTransaction>;
    @Field(() => [Order], {nullable:true})
    orders?: Array<Order>;
    @Field(() => [Session], {nullable:true})
    sessions?: Array<Session>;
    @Field(() => [Hotel], {nullable:true})
    hotelsCreated?: Array<Hotel>;
    @Field(() => [Program], {nullable:true})
    programsParticipation?: Array<Program>;
    @Field(() => [Project], {nullable:true})
    projectsInvestment?: Array<Project>;
    @Field(() => [Reward], {nullable:true})
    claimedRewards?: Array<Reward>;
    @Field(() => [UserNotification], {nullable:true})
    userNotifications?: Array<UserNotification>;
    @Field(() => [Program], {nullable:true})
    programsCreated?: Array<Program>;
    @Field(() => [File], {nullable:true})
    filesCreated?: Array<File>;
    @Field(() => UserCount, {nullable:false})
    _count?: InstanceType<typeof UserCount>;
}

@ObjectType()
export class AggregateUserNotification {
    @Field(() => UserNotificationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregate>;
    @Field(() => UserNotificationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregate>;
    @Field(() => UserNotificationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregate>;
    @Field(() => UserNotificationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregate>;
    @Field(() => UserNotificationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregate>;
}

@ArgsType()
export class CreateManyUserNotificationArgs {
    @Field(() => [UserNotificationCreateManyInput], {nullable:false})
    @Type(() => UserNotificationCreateManyInput)
    data!: Array<UserNotificationCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneUserNotificationArgs {
    @Field(() => UserNotificationCreateInput, {nullable:false})
    @Type(() => UserNotificationCreateInput)
    data!: InstanceType<typeof UserNotificationCreateInput>;
}

@ArgsType()
export class DeleteManyUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
}

@ArgsType()
export class DeleteOneUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstUserNotificationOrThrowArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindFirstUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindManyUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueUserNotificationOrThrowArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyUserNotificationArgs {
    @Field(() => UserNotificationUpdateManyMutationInput, {nullable:false})
    @Type(() => UserNotificationUpdateManyMutationInput)
    data!: InstanceType<typeof UserNotificationUpdateManyMutationInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
}

@ArgsType()
export class UpdateOneUserNotificationArgs {
    @Field(() => UserNotificationUpdateInput, {nullable:false})
    @Type(() => UserNotificationUpdateInput)
    data!: InstanceType<typeof UserNotificationUpdateInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationCreateInput, {nullable:false})
    @Type(() => UserNotificationCreateInput)
    create!: InstanceType<typeof UserNotificationCreateInput>;
    @Field(() => UserNotificationUpdateInput, {nullable:false})
    @Type(() => UserNotificationUpdateInput)
    update!: InstanceType<typeof UserNotificationUpdateInput>;
}

@ArgsType()
export class UserNotificationAggregateArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserNotificationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregateInput>;
    @Field(() => UserNotificationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregateInput>;
    @Field(() => UserNotificationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregateInput>;
    @Field(() => UserNotificationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregateInput>;
    @Field(() => UserNotificationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregateInput>;
}

@InputType()
export class UserNotificationAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class UserNotificationAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class UserNotificationAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class UserNotificationCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    title!: number;
    @Field(() => Int, {nullable:false})
    subtitle!: number;
    @Field(() => Int, {nullable:false})
    content!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    category!: number;
    @Field(() => Int, {nullable:false})
    isRead!: number;
    @Field(() => Int, {nullable:false})
    isCleared!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    deepLink!: number;
    @Field(() => Int, {nullable:false})
    fcmToken!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class UserNotificationCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationCreateManyUserInputEnvelope {
    @Field(() => [UserNotificationCreateManyUserInput], {nullable:false})
    @Type(() => UserNotificationCreateManyUserInput)
    data!: Array<UserNotificationCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserNotificationCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateNestedManyWithoutUserInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
}

@InputType()
export class UserNotificationCreateOrConnectWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationCreateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create!: InstanceType<typeof UserNotificationCreateWithoutUserInput>;
}

@InputType()
export class UserNotificationCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
    @Field(() => UserCreateNestedOneWithoutUserNotificationsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutUserNotificationsInput>;
}

@ArgsType()
export class UserNotificationGroupByArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithAggregationInput>;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof UserNotificationScalarFieldEnum>;
    @Field(() => UserNotificationScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserNotificationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregateInput>;
    @Field(() => UserNotificationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregateInput>;
    @Field(() => UserNotificationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregateInput>;
    @Field(() => UserNotificationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregateInput>;
    @Field(() => UserNotificationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregateInput>;
}

@ObjectType()
export class UserNotificationGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    content!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:false})
    isRead!: boolean;
    @Field(() => Boolean, {nullable:false})
    isCleared!: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
    @Field(() => UserNotificationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregate>;
    @Field(() => UserNotificationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregate>;
    @Field(() => UserNotificationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregate>;
    @Field(() => UserNotificationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregate>;
    @Field(() => UserNotificationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregate>;
}

@InputType()
export class UserNotificationListRelationFilter {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    every?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    some?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    none?: InstanceType<typeof UserNotificationWhereInput>;
}

@InputType()
export class UserNotificationMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
}

@ObjectType()
export class UserNotificationMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    title?: string;
    @Field(() => String, {nullable:true})
    subtitle?: string;
    @Field(() => String, {nullable:true})
    content?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:true})
    category?: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
}

@ObjectType()
export class UserNotificationMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    title?: string;
    @Field(() => String, {nullable:true})
    subtitle?: string;
    @Field(() => String, {nullable:true})
    content?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:true})
    category?: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deepLink?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    fcmToken?: InstanceType<typeof SortOrderInput>;
    @Field(() => UserNotificationCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountOrderByAggregateInput>;
    @Field(() => UserNotificationAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgOrderByAggregateInput>;
    @Field(() => UserNotificationMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxOrderByAggregateInput>;
    @Field(() => UserNotificationMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinOrderByAggregateInput>;
    @Field(() => UserNotificationSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumOrderByAggregateInput>;
}

@InputType()
export class UserNotificationOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deepLink?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    fcmToken?: InstanceType<typeof SortOrderInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class UserNotificationScalarWhereWithAggregatesInput {
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    title?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    content?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => EnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => BoolWithAggregatesFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolWithAggregatesFilter>;
    @Field(() => BoolWithAggregatesFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableWithAggregatesFilter>;
}

@InputType()
export class UserNotificationScalarWhereInput {
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    AND?: Array<UserNotificationScalarWhereInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    OR?: Array<UserNotificationScalarWhereInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    NOT?: Array<UserNotificationScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
}

@InputType()
export class UserNotificationSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class UserNotificationSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class UserNotificationSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
}

@InputType()
export class UserNotificationUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => [UserNotificationUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<UserNotificationUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<UserNotificationUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [UserNotificationUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<UserNotificationUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    @Type(() => UserNotificationScalarWhereInput)
    deleteMany?: Array<UserNotificationScalarWhereInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateManyWithWhereWithoutUserInput {
    @Field(() => UserNotificationScalarWhereInput, {nullable:false})
    @Type(() => UserNotificationScalarWhereInput)
    where!: InstanceType<typeof UserNotificationScalarWhereInput>;
    @Field(() => UserNotificationUpdateManyMutationInput, {nullable:false})
    @Type(() => UserNotificationUpdateManyMutationInput)
    data!: InstanceType<typeof UserNotificationUpdateManyMutationInput>;
}

@InputType()
export class UserNotificationUpdateManyWithoutUserNestedInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => [UserNotificationUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<UserNotificationUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<UserNotificationUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [UserNotificationUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<UserNotificationUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    @Type(() => UserNotificationScalarWhereInput)
    deleteMany?: Array<UserNotificationScalarWhereInput>;
}

@InputType()
export class UserNotificationUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationUpdateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationUpdateWithoutUserInput)
    data!: InstanceType<typeof UserNotificationUpdateWithoutUserInput>;
}

@InputType()
export class UserNotificationUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutUserNotificationsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutUserNotificationsNestedInput>;
}

@InputType()
export class UserNotificationUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationUpdateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationUpdateWithoutUserInput)
    update!: InstanceType<typeof UserNotificationUpdateWithoutUserInput>;
    @Field(() => UserNotificationCreateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create!: InstanceType<typeof UserNotificationCreateWithoutUserInput>;
}

@InputType()
export class UserNotificationWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    AND?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    OR?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    NOT?: Array<UserNotificationWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class UserNotificationWhereInput {
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    AND?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    OR?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    NOT?: Array<UserNotificationWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class UserNotification {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    content!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:false,defaultValue:false})
    isRead!: boolean;
    @Field(() => Boolean, {nullable:false,defaultValue:false})
    isCleared!: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink!: string | null;
    @Field(() => String, {nullable:true})
    fcmToken!: string | null;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
}
